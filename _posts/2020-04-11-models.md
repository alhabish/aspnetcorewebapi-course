---
layout: post
title: "3. Models"
date: 2020-04-11
lang: ar-SA
index: 3
comments: true
---

مشكلة إنشاء كنترولر بإستخدام أداة dotnet-aspnet-codegenerator هي إعتماد الكنترولر على الـ database context الخاص بـ entity framework ولو أردنا فيما بعد الإستغناء عن EF أو تغيير قاعدة البيانات الى Mongo أو Cosmos DB أو غيرها سيصعب علينا ذلك بسبب الإعتمادية العالية high coupling الموجوده في الكود.

## Repository Pattern

سنعدل على الكود لتقل الإعتمادية على backend  معيّن بإستخدام نموذج البناء هذا بإتباع الخطوات التالية:


قم بإنشاء مجلد جديد بإسم Data وبداخله ملف بإسم IEmployeesRepo.cs:

```csharp
using System.Collections.Generic;
using System.Threading.Tasks;

namespace aspnetcorewebapiproject.Data
{
    public interface IRepository<T> where T : class
    { 
        Task<List<T>> GetAllAsync();
        Task<T> GetAsync(int id);
        Task<int> InsertAsync(T entity);
        Task<int> UpdateAsync(T entity);        
        Task<T> DeleteAsync(int id);
    } 
}
```

من الملاحظ أنه لا يوجد في أسماء الدوال في الـ interface ما يدل على أنها متعلقة بالـ Employee. فلم نقل GetEmployees بل Get ولم نقل InsertEmployee بل hnsert وكذلك بقية الدوال، وعلى ذلك بإمكاننا أن نجعل هذا الـ iterface عام generic بدون تخصيص بإستخدام الـ generics كما يلي:

```csharp
public interface IRepo<T>
{
    bool Exists(int id);
    Task<List<T>> Get();
    Task<T> Get(int id);
    Task Add(T entity);
    Task Update(T entity);
    Task Delete(T entity);
}     

public class EfRepo : IRepo<Entities.Employee>
{
    ...
}
```

ولكننا في درسنا هذا لن نفعل ذلك لإبقاء الكود بأسهل صيغة ممكنه وذلك ليسهل فهمها وإستيعابها.





الآن في EmployeesController نحذف الكود الذي على MainDbContext مباشرة. 

نحذف أولاً هذا السطر:

```csharp
private readonly MainDbContext _context;
```

ونضيف بداله السطر التالي:

```csharp
Data.IRepository<Entities.Employee> _repo;
```

ويصبح الـ constructor بالشكل التالي:

```csharp
        public EmployeesController(Data.IRepository<Entities.Employee> repo)
        {
            _repo = repo;
        }
```

بالنسبة لـ GetEmployees() فهنالك تغييران يجب علينا القيام بها، الأول هو أن نعيد Http Status Code مع البيانات المسترجعة وذلك ممكن بإحتواء البيانات داخل الدالة Ok(). أما الثاني فهو إرجاع البيانات من الـ repo الجديد وليس من الـ MainDbContext السابق.

```csharp
        // GET: api/Employees
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Employee>>> GetEmployees()
        {
            return Ok( await _repo.GetAll()  );
        }
```

GetEmployee() أيضا ستقوم بإرجاع Http Status Code 200 في حالة وجدنا الموظف الذي يحمل نفس الـ Id، أما في حالة لم نجده فهي من الأساس ترجع القيمة Http Status Code 404 عن طريق الدالة NotFound() وبذلك تصبح:

```csharp
        // GET: api/Employees/5
        [HttpGet("{id}")]
        public async Task<ActionResult<Employee>> GetEmployee(int id)
        {
            var employee = await _repo.Get(id);

            if (employee == null)
            {
                return NotFound();
            }

            return Ok( employee );
        }
```

بالنسبة لـ PUT ففي حالة لم يكن هتلك مشكلة سيتم التحديث ونعيد NoContent، أما في حالة وجود مشكلة فإما تكون بسبب أنه لا يوجد موظف بهذا الـ Id وفي هذه الحالة نعيد NotFound أما في حالة وجود مشكلة في الـ backend نعيد Http Status Code 500:

```csharp
        [HttpPut("{id}")]
        public async Task<IActionResult> PutEmployee(int id, Employee employee)
        {
            if (id != employee.Id)
            {
                return BadRequest();
            }

            try
            {
                await _repo.Update(employee);
            }
            catch (Exception)
            {
                if (await _repo.Get(id) == null)
                {
                    return NotFound();
                }
                else
                {
                    return StatusCode(StatusCodes.Status500InternalServerError);
                }
            }

            return NoContent();
        }
```
