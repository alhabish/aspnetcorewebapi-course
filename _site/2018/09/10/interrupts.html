<!doctype html>
<html dir="rtl" lang="ar-SA">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>المُقاطعات Interrupts | لنتعلم برمجة الأنظمة المدمجة</title>
<meta property="og:title" content="المُقاطعات Interrupts" />
<meta name="author" content="خالد الغامدي" />
<meta property="og:locale" content="ar_SA" />
<meta name="description" content="توجد طريقتان لتتمكن المعالجات الدقيقة microprocessors من خدمة الأجهزة المختلفة التي تتصل بها، وهي إما:" />
<meta property="og:description" content="توجد طريقتان لتتمكن المعالجات الدقيقة microprocessors من خدمة الأجهزة المختلفة التي تتصل بها، وهي إما:" />
<link rel="canonical" href="http://localhost:4000/2018/09/10/interrupts.html" />
<meta property="og:url" content="http://localhost:4000/2018/09/10/interrupts.html" />
<meta property="og:site_name" content="لنتعلم برمجة الأنظمة المدمجة" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-10T00:00:00+03:00" />
<script type="application/ld+json">
{"name":null,"description":"توجد طريقتان لتتمكن المعالجات الدقيقة microprocessors من خدمة الأجهزة المختلفة التي تتصل بها، وهي إما:","author":{"@type":"Person","name":"خالد الغامدي"},"@type":"BlogPosting","url":"http://localhost:4000/2018/09/10/interrupts.html","publisher":null,"image":null,"headline":"المُقاطعات Interrupts","dateModified":"2018-09-10T00:00:00+03:00","datePublished":"2018-09-10T00:00:00+03:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/09/10/interrupts.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script type="text/javascript" src="/assets/js/jquery-1.12.4.min.js" ></script>
    <script type="text/javascript" src="/assets/js/main.js"></script>
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>لنتعلم برمجة الأنظمة المدمجة</h1>
		<h3 text-align="left">Embedded Systems Programming Bootcamp</h3>
        <p>كورس تعليمي يهدف الى اكسابك المعرفة اللازمة والمهارات التقنية المتعلقة ببرمجة وتطوير الأنظمة المدمجة وفهم خصائصها ومكوناتها</p>
        <p class="view">
            <a href="/">الصفحة الرئيسية</a><br>
            <!--<a href="/#contents">الدروس</a><br>-->
            <a href="/lessons.html">قائمة الدروس</a><br>
            <a href="/feed.xml" title="Subscribe to our RSS feed">خدمة RSS</a>
        </p>
        <!--/assets/images/sidebar/rss.svg-->
          <!--<aside>-->
    <h3>للتواصل</h3>
    <ul class="social">
    <li><a href="https://github.com/alhabish/embedded-course" title="Github" class="github">Github</a></li>
    <li><a href="mailto:alhabish@gmail.com" title="Email" class="mail">Email</a></li>
    <li><a href="https://www.linkedin.com/in/khalidalghamidi" title="Linked in" class="linked">LinkedIn</a></li>
    <li><a href="http://www.twitter.com/alhabish" title="Twitter" class="twitter">Twitter</a></li>
    </ul>
    <!--</aside>-->
          
<!--        
        

        

        
-->
      </header>
      <section>

      <h1>14. المُقاطعات  Interrupts</h1>
<p class="meta">2018-09-10</p>


<!-- from https://github.com/cstack/db_tutorial -->


      
      

    <hr>
      
          <a class="prev" href="/2018/09/11/ADC.html">14. المُقاطعات  Interrupts</a> <br>
      
      
          <a class="next" href="/2018/08/17/i2c.html">13. بروتوكول الإتصال المتزامن I2C</a> <br>
      
    <br>
    <hr>

    <p><p>توجد طريقتان لتتمكن المعالجات الدقيقة microprocessors من خدمة الأجهزة المختلفة التي تتصل بها، وهي إما:</p>

<ul>
  <li>المُقاطعات interrupts أو</li>
  <li>الإستعلام المتكرر  polling</li>
</ul>

<p>في حالة الإستعلام، يقوم المعالج بمراقبة حالة الجهاز بإستمرار وينتظر حتى إستيفاء الحالة أو تحقق الشرط المطلوب ثم يقوم بتنفيذ الأوامر المطلوبة، وبعد إكتمال عملية تنفيذ المهمة، يقوم المعالج بتنفيذ المهمة التي تليها.</p>

<p>فعلى سبيل المثال، في درس SysTick Timer، راقبنا بإستمرار قيمة الحقل COUNT لحينما تصبح 0 وذلك لضمان انقضاء الوقت المحدد:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="c1">// wait until COUNT is flagged
</span><span class="k">while</span> <span class="p">((</span><span class="n">STCTRL_R</span> <span class="o">&amp;</span> <span class="mh">0x00010000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<p>لكن، وكما هو واضح، المعالج مشغول بمراقبة هذه القيمة ولن يتمكن من الإنتقال الى تنفيذ الأوامر الموجودة بعد هذا السطر طالما لم يتحقق. ونحن بهذه الطريقة لم نستغل المعالج بشكل فعّال حيث نهدر الكثير من الوقت والطاقة لمراقبة قيّم وأجهزة ليست بحاجتنا الى أن نلتفت اليها.</p>

<p>ولكن، بإستخدام المُقاطعات فإنه عندما يحتاج أي جهاز إلى خدمة ما، فإنه يقوم بإعلام المعالج بذلك عن طريق إرسال إشارة المقاطعة Interrupt Request - IRQ. وعندما يتلقي المعالج هذه الإشارة، فإنه “يقطع” ما يقوم به في تلك اللحظة ويلتفت الى خدمة الجهاز المرسل للإشارة. وبذلك يتمكن المعالج من خدمة الجهاز دون مراقبة حالته بشكل مستمر. ولذلك ينصح بإستخدام المُقاطعات.</p>

<hr />

<h2><a href=""></a> شرح الخطوات</h2>

<p>فيما يلي شرح مختصر لما يحدث عند إرسال مُقاطعة:</p>

<ol>
  <li>
    <p>عندما يحتاج منفذ port أو جهاز طرفي peripheral الى خدمة من المعالج فإنه يرسل إشارة بذلك. هذه الإشارة تسمى طلب المُقاطعة Interrupt Request - IRQ.</p>
  </li>
  <li>
    <p>قد يكون المعالج في وضع السكون أو مشغولاً بأداء مهام أخرى، ولكن حينما يصله طلب المقاطعة فإنه يقوم بتعليق المهمة التي ينفذها ويحفظ مكانها.</p>
  </li>
  <li>
    <p>يبحث المعالج في جدول المقاطعات Interrupt Vector Table - IVT للعثور على الدالة function المرتبطة بالمقاطعة والتي يجب عليه تنفيذها عند حدوث هذه المقاطعة.</p>
  </li>
  <li>
    <p>يتم بعد بعد ذلك تنفيذ الدالة المرتبطة بالمُقاطعة Interrupt Service Routine - ISR. وبمجرد اكتمال تنفيذها، يعود المعالج لتنفيذ المهام التى كان يعمل عليها قبل إستقبال طلب المقاطعة.</p>
  </li>
</ol>

<p>وفيما يلي سنلقي نظرة على الأجزاء المختلفة المتعلقة بالمُقاطعات في متحكمات ARM Cortex-M:</p>

<hr />

<h2><a href=""></a> Nested Vectored Interrupt Controller - NVIC</h2>

<p>تتم عملية إدارة المقاطعات بواسطة وحدة Nested Vector Interrupt Controller - NVIC، والتي توفر عدة خصائص من ضمنها تمكين/الغاء خاصية إستقبال المقاطعات وتحديد أولويات المقاطعات وتنفيذها حسب هذه الأولوية حيث أن جميع المقاطعات interrupts والاستثناءات exceptions لها مستويات أولوية معينة. وبشكل عام فإن الاستثناء مماثل للمقاطعة غير أن مستوى الأولوية priority فيه أعلى. أيضاً، يستقبل الـ NVIC المقاطعات أثناء تنفيذ مقاطعة أخرى ويقوم بالمقارنة بينها، فإذا كان مستوى الأولوية للمقاطعة المستقبلة أعلى، سيتم تعليق تنفيذ المقاطعة الحالية وتقديم المقاطعة المستقبلة أولاً.</p>

<hr />

<h2><a href=""></a> دالة خدمة المقاطعة Interrupt service routine - ISR</h2>

<p>يجب أن يكون هنالك لكل مقاطعة دالة مرتبطه بها يتم تنفيذها عند حدوث المقاطعة. ويشار إليها عادةً باسم دالة خدمة المقاطعة Interrupt service routine - ISR.</p>

<p>عند إنشاء مشروع جديد في Keil µVision IDE سينشئ البرنامج تلقائيًا ملف بدء تشغيل startup file بإسم startup_TM4C123.s. وستجد فيه لكل مقاطعة دالة خدمة مقاطعة ISR وهمية لا تقوم بأي شيء placeholder في Vectors_.</p>

<p>ولكتابة هذه الدالة، سنحتاج أولاً إلى معرفة اسمها في جدول Vectors_ وإستخدام ذلك الاسم في برنامجنا وبعد ذلك سيقوم الـ linker بإعادة كتابة العنوان الجديد للدالة عند عمل تجميع compile للبرنامج.</p>

<hr />

<h2><a href=""></a> جدول المقاطعات Interrupt Vector Table - IVT</h2>

<p>في صفحة 107 من دليل البيانات بإمكاننا أن نرى جدول المقاطعات والذي يحتوي على عناوين دوال خدمة المقاطعات ISRs:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/vector_table.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/vector_table.png');" />
    </td>
</tr>
</table>

<p>ويمكن العثور على هذا جدول وبشكل مفصل في ملف startup_TM4C123.s.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/vectors.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/vectors.png');" />
    </td>
</tr>
</table>

<p>حيث يمكن استخدام العناصر الموجودة في العمود الثاني كأسماء ISR في البرنامج بينما نستخدم الـ IRQ لإعداد المقاطعة في البرنامج.</p>

<hr />

<h2><a href=""></a> تفعيل أو إيقاف المقاطعات بشكل عام</h2>

<p>بالإمكان تفعيل أو إيقاف المقاطعات بشكل عام في هيكلة ARM Cortex M بإستخدام الأوامر التالية في لغة الـ Assembly:</p>

<ul>
  <li>CPSIE I لتفعيل المقاطعات</li>
  <li>CPSID I لإيقاف المقاطعات</li>
</ul>

<p>ويوفر لنا الكومبايلر في Keil µVision الدوال التالية التي تستدعي الأوامر السابقة:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__enable_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>  <span class="c1">// CPSIE I;
</span><span class="kt">void</span> <span class="n">__disable_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="c1">// CPSID I;
</span></code></pre>
</div>

<p>ولكن ينقصها أمر لوقف التنفيذ لحينما تحدث مقاطعة. ولذلك سنقوم بإعادة كتابة الدوال السابقة وإضافة دالة التوقف اليها بلغة الـ assembly وإستدعائها من الـ C.</p>

<p>فتكون الدالة المتعلقة بإيقاف المقاطعات:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">interrupts_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kr">__asm</span> <span class="p">(</span><span class="s">"CPSID  I</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>والدالة التي تفعلها:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">interrupts_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kr">__asm</span>  <span class="p">(</span><span class="s">"CPSIE  I</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>والدالة التي توقف التنفيذ لحين حدوث مقاطعة:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">interrupts_wait_for</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kr">__asm</span>  <span class="p">(</span><span class="s">"WFI</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<hr />

<h2><a href=""></a> مثال على الإستثناءات</h2>

<p>كما ذكرنا سابقاً فإن الاستثناءات مماثلة للمقاطعات ولكن مستوى الأولوية فيها أعلى. وكمثال، سنأخذ الاستثناء الناجم عن مؤقت النظام SysTick.</p>

<p>ذكرنا في درس سابق، بأن معالج Cortex-M4 يحتوي على مؤقت من 24-bit، والذي يبدأ العد من قيمة إعادة التحميل RELOAD إلى الصفر. وعند الوصول إلى الصفر يقوم مؤقت النظام SysTick بإعادة تحميل القيمة المخزنة في RELOAD وتستأنف العد التنازلي.</p>

<p>ما يهمنا هنا هو أنه عند الوصول إلى الصفر، سوف يرسل المؤقت المقاطعة والتي سنقوم في برنامجنا بالتعامل معها.</p>

<p>في ملف startup_TM4C123.s يتضح لنا أن الـ ISR للـ SysTick هي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">SysTick_Handler</span>
</code></pre>
</div>

<p>نضيفها الى ملف الـ c الذي أنشأناه كما يلي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">SysTick_Handler</span> <span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre>
</div>

<p>وسيتم تنفيذ ما بداخل هذه الدالة كلما أرسل الـ SysTick إشارة الى المعالج، أي كلما وصل العداد الى 0. وما نود تنفيذه في هذه الدالة هو تشغيل الإضاءة الحمراء على البورد إن كانت طافئة وإطفاءها إن كانت مضيئة:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">SysTick_Handler</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">^=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// toggle red led
</span><span class="p">}</span>
</code></pre>
</div>

<p>أوامر تهيئة المؤقت SysTick مشابهه لما هو موجود في الدرس التاسع ولكن في ذلك الدرس الغينا عمل المقاطعات في سجل STCTRL بينما نفعله هنا:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">NVIC_ST_CTRL_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// enable SysTick interrupt
</span></code></pre>
</div>

<p>ما يهمنا هنا هو إضافة الأسطر التالية بعد التهيئة:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="c1">// Global enable interrupt
</span>  <span class="n">interrupts_enable</span><span class="p">();</span> 
  
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">interrupts_wait_for</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre>
</div>

<p>حيث أن السطر الأول يفعّل المُقاطعات ثم ندخل في عملية تكرار مستمرة ولكن الأمر interrupts_wait_for يوقف المعالج الى حين حدوث مقاطعة.</p>

<p>وبذلك يكون كامل الكود لدينا:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include "C:\ti\TivaWare_C_Series-2.1.4.178\inc\tm4c123gh6pm.h"
</span>
<span class="kt">void</span> <span class="n">portf_config_gpio</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">systick_config</span>    <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">interrupts_disable</span>  <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">interrupts_enable</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">interrupts_wait_for</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">SysTick_Handler</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// toggle red led
</span>  <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">^=</span> <span class="mi">2</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">portf_config_gpio</span> <span class="p">(</span> <span class="p">);</span>
  <span class="n">systick_config</span> <span class="p">(</span> <span class="p">);</span>
    
  <span class="n">interrupts_enable</span><span class="p">();</span> 

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">interrupts_wait_for</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">portf_config_gpio</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// enable clock to GPIOF at clock gating control register
</span>  <span class="n">SYSCTL_RCGCGPIO_R</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>
  
  <span class="c1">// enable the GPIO pins for the LED (PF3,2,1) as output
</span>  <span class="n">GPIO_PORTF_DIR_R</span> <span class="o">=</span> <span class="mh">0x0E</span><span class="p">;</span>

  <span class="c1">// disable alt funct on PF3-1
</span>  <span class="n">GPIO_PORTF_AFSEL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0E</span><span class="p">;</span> 
  
  <span class="c1">// enable the GPIO pins for digital function
</span>  <span class="n">GPIO_PORTF_DEN_R</span> <span class="o">=</span> <span class="mh">0x0E</span><span class="p">;</span>  
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">systick_config</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// disable SysTick during setup
</span>  <span class="n">NVIC_ST_CTRL_R</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         
  
  <span class="c1">// reload with number of clocks per second
</span>  <span class="n">NVIC_ST_RELOAD_R</span> <span class="o">=</span> <span class="mi">16000000</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> 

  <span class="c1">// configure SysTick
</span>  <span class="n">NVIC_ST_CTRL_R</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>  <span class="o">|</span>  <span class="c1">// 4.1) enable SysTick interrupt
</span>                    <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>  <span class="o">|</span>  <span class="c1">// 4.2) use system clock
</span>                    <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>   <span class="c1">// 4.3) enable SysTick   
</span><span class="p">}</span>

<span class="kt">void</span> <span class="n">interrupts_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kr">__asm</span> <span class="p">(</span><span class="s">"CPSID  I</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">interrupts_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kr">__asm</span>  <span class="p">(</span><span class="s">"CPSIE  I</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">interrupts_wait_for</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kr">__asm</span>  <span class="p">(</span><span class="s">"WFI</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
</div>

<hr />

<h2><a href=""></a> مثال عل المقاطعات</h2>

<p>في هذا الدرس سوف نعيد كتابة المثال في الدرس الثامن ليستخدم المقاطعات interrupts بدلاً من الإستعلام المتكرر polling.</p>

<p>وللتذكير فإن البرنامج كان يتعامل مع الأزرار والإضاءات في البورد حيث تختلف الإضاءة حسب الزر المضغوط.</p>

<p>وفيما يلي جدول يختصر هذه الحالات:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">حالة الأزرار</th>
      <th style="text-align: right">حالة الإضاءة</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">الضغط على SW1 و SW2 معاً</td>
      <td style="text-align: right">الإضاءة الحمراء تعمل</td>
    </tr>
    <tr>
      <td style="text-align: right">الضغط على SW1 فقط</td>
      <td style="text-align: right">الإضاءة الزرقاء تعمل</td>
    </tr>
    <tr>
      <td style="text-align: right">الضغط على SW2 فقط</td>
      <td style="text-align: right">الإضاءة الخضراء تعمل</td>
    </tr>
  </tbody>
</table>

<p>حيث أن:</p>

<ul>
  <li>الزر الأيسر SW1 متصل بالمنفذ F والطرف 4 =&gt;  PF4</li>
  <li>الزر الأيمن SW2 متصل بالمنفذ F والطرف 0 =&gt;  PF0</li>
</ul>

<p>بالإضافة الى أننا سنتعامل مع الإضاءات الملونة التي تعاملنا معها سابقاً:</p>

<ul>
  <li>الإضاءة الحمراء  Red LED  متصلة بالمنفذ F والطرف 1 =&gt;  PF1</li>
  <li>الإضاءة الزرقاء  Blue LED  متصلة بالمنفذ F والطرف 2 =&gt;  PF2</li>
  <li>الإضاءة الخضراء  Green LED  متصلة بالمنفذ F والطرف 3 =&gt;  PF3</li>
</ul>

<p>ونظرًا لأن التهيئة المتعلقة بالـ GPIO قد تمت مناقشتها مسبقاً فإننا هنا سننظر الى تهيئة المقاطعات فقط.</p>

<hr />

<h2><a href=""></a> تهيئة المقاطعات</h2>

<p>أول ثلاث خطوات في عملية تهيئة المقاطعات تتعلق بتحديد نقطة بدء trigger المقاطعة، حيث أنه لدينا 5 خيارات بالإمكان للمقاطعة أن تعمل عندها:</p>

<ul>
  <li>المستوى المنخفض  low level</li>
  <li>المستوى العالي high level</li>
  <li>الحافة الصاعدة rising edge من المستوى المنخفض إلى المرتفع</li>
  <li>الحافة النازلة falling edge من المستوى المرتفع إلى المنخفض</li>
  <li>كلا الحافتين الصاعدة والنازلة</li>
</ul>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/signal_edges.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/signal_edges.png');" />
    </td>
</tr>
</table>

<p>وفيما يلي خطوات التهيئة التي يجب علينا إتباعها:</p>

<hr />

<p><strong>1. تحديد ما إذا كنا سنستخدم المستويات (عالي أم منخفض) أو الحواف (صاعد أم نازل) للإشارة على بدء المقاطعة</strong></p>

<p>للقيام بذلك نستخدم السجل GPIOIS ص 664.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/GPIOIS.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/GPIOIS.png');" />
    </td>
</tr>
</table>

<p>نحن هنا سنستخدم الحافة النازلة للإشارة للمقاطعة ولذلك نضع 0 في الخانات المقابلة للأزرار (بت 0 للمفتاح SW2 وبت 4 للمفتاح SW1)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTF_IS_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<hr />

<p><strong>2. تحديد ما إذا كنا نريد للإشارة أن تحدث لكلا المستويين (عالي ومنخفض) أو الحافتين (الصاعدة والنازلة)</strong></p>

<p>ويكون ذلك عن طريق السجل GPIOIBE ص 665.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/GPIOIBE.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/GPIOIBE.png');" />
    </td>
</tr>
</table>

<p>وبما أنا قلنا أننا نريد الحافة النازلة فقط، فإننا نضع 0 في الخانات المقابلة للأزرار (بت 0 للمفتاح SW2 وبت 4 للمفتاح SW1)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTF_IBE_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<hr />

<p><strong>3. تحديد ما اذا كنا نريد المستوى العالي و الحافة الصاعدة أم المستوى المنخفض و الحافة النازلة</strong></p>

<p>ويتم ذلك عن طريق السجل GPIOIEV ص 666.</p>

<p>في الحالة الأولى (مستوى عالي أو حافة صاعدة) نضع القيمة 1 في الخانات المقابلة للأزرار (بت 0 للمفتاح SW2 وبت 4 للمفتاح SW1). أما في الحالة الثانية (مستوى منخفض أو حافة نازلة) فإننا نضع 0.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTF_IEV_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<hr />

<p><strong>4.  مسح أي مقاطعة سابقة متعلقة بالأطراف</strong></p>

<p>وذلك عن طريق السجل GPIOICR ص 670.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/GPIOICR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/GPIOICR.png');" />
    </td>
</tr>
</table>

<p>للتأكد من مسح أي مقاطعة سابقة فإننا نضع القيمة 1 في الخانات المقابلة للأزرار (بت 0 للمفتاح SW2 وبت 4 للمفتاح SW1).</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTF_ICR_R</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<hr />

<p><strong>5. تعيين أولوية للمقاطعة</strong></p>

<p>ويتم ذلك عن طريق سجلات PRIn ص 152.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/PRIn.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/PRIn.png');" />
    </td>
</tr>
</table>

<p>تكون سجلات الأولية priority على الشكل التالي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">NVIC_PRIn_R</span>
</code></pre>
</div>

<p>حيث يمثل n رقم المجموعة التى تتحكم بأولويات المقاطعات في هذه المجموعة. ولمعرفة الرقم الذي يجب علينا إستبدال n به فإن أسهل طريقة لتحديد السجل الذي سنستخدمه هو عن طريق فتح دليل البيانات وإستعراض الـ Bookmarks، وتحت التبويب 3. Cortex-M4 Peripherals نختار 3.4. NVIC Register Descriptions:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/bookmarks.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/bookmarks.png');" />
    </td>
</tr>
</table>

<p>إبحث عن سجلات الأولوية Priority التي تبدأ من سجل 29 وتنتهي بالسجل 63.</p>

<p>إفتح الملف startup_TM4C123.s وإبحث عن GPIOF_Handler. هذه الدالة هي الـ ISR الخاصة بالمقاطعات المتعلقة بالمنفذ F. ما يهمنا هنا هو رقم الـ IRQ لهذه الدالة وهو 30. وكل ما علينا فعله هنا هو البحث عن السجل الذي يشمل المقاطعة رقم 30 وهو السجل رقم 36 حيث يشمل المقاطعات من 28 الى 31.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/PRI7.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/PRI7.png');" />
    </td>
</tr>
</table>

<p>أي أنه يجب علينا إستخدام المجموعة رقم 7 وبذلك فإننا نستخدم السجل التالي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">NVIC_PRI7_R</span>
</code></pre>
</div>

<p>وهذه المجموعة السابعة بإمكانها التحكم بأولوية المقاطعات 28 و 29 و 30 و 31 بحيث يكون لكل مقاطعة 3 بتات نحدد فيها أولويتها. أي من 000 الى 111 (ثنائي) أو من 0 الى 7 (عشري):</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/28293031.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/28293031.png');" />
    </td>
</tr>
</table>

<p>وبذلك يكون الحقل المتحكم في أولوية المقاطعة رقم 30 هو INTC (بت 23:21).</p>

<p>وسنقوم بإعطاء هذه المقاطعة الأولوية 3:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">NVIC_PRI7_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">);</span>
</code></pre>
</div>

<hr />

<p><strong>6. تمكين المقاطعات للمنفذ</strong></p>

<p>مرة أخرى، عن طريق فتح دليل البيانات وإستعراض الـ Bookmarks، وتحت التبويب 3. Cortex-M4 Peripherals نختار 3.4. NVIC Register Descriptions. وكل ما علينا فعله هنا هو البحث في سجلات ENn عن السجل الذي يشمل المقاطعة رقم 30 وهو السجل رقم 4 أي EN0 حيث يشمل المقاطعات من 0 الى 31.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/EN0.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/EN0.png');" />
    </td>
</tr>
</table>

<p>وتفاصيل السجل موجودة في ص 142 من دليل البيانات:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/EN0_R.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/EN0_R.png');" />
    </td>
</tr>
</table>

<p>نضع الآن القيمة 1 في الخانة 30 لأنها تقابل IRQ رقم 30.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">NVIC_EN0_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span>
</code></pre>
</div>

<hr />

<p><strong>7. تمكين المقاطعات للأطراف</strong></p>

<p>ويكون ذلك عن طريق السجل GPIOIM ص 667.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_14/GPIOIM.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_14/GPIOIM.png');" />
    </td>
</tr>
</table>

<p>لتمكين المقاطعات للأطراف نضع القيمة 1 في الخانات المقابلة للأزرار (بت 0 للمفتاح SW2 وبت 4 للمفتاح SW1).</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTF_IM_R</span> <span class="o">|=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<hr />

<p><strong>8. تمكين المقاطعات بشكل عام</strong></p>

<p>سنستدعي هنا الدالة التي قمنا بكتابتها interrupts_enable :</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">interrupts_enable</span><span class="p">();</span>
</code></pre>
</div>

<hr />

<p><strong>9. كتابة دالة خدمة المقاطعة ISR</strong></p>

<p>وجدنا في الملف startup_TM4C123.s إن الـ ISR المسؤول عن المقاطعات الخاصة بالمنفذ F هي GPIOF_Handler. ولذلك ننسخ إسمها ونضعه في ملفنا كالتالي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">GPIOF_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre>
</div>

<p>أول ما نفعله هنا هو إزالة إشارة المقاطعة قبل العودة الى التعامل مع المقاطعة. لأننا لو لم نقم بذلك فإن المقاطعة ستظهر كما لو أنها كانت لا تزال معلقة وسيتم تنفيذ دالة خدمة المقاطعة ISR مرة تلو الأخرى وبشكل مستمر الى أن يعلق البرنامج.</p>

<p>نقوم بإزالة إشارة المقاطعة عن طريق وضع القيمة 1 في الخانات المقابلة للأزرار (بت 0 للمفتاح SW2 وبت 4 للمفتاح SW1).</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTF_ICR_R</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<p>بعد ذلك نتعامل مع المقاطعة كما نريد، وفي حالتنا هذه نختبر أي الأزرار تم الضغط عليه لإضائة النور المناسب.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">switch</span> <span class="p">(</span><span class="n">GPIO_PORTF_DATA_R</span> <span class="o">&amp;</span> <span class="mh">0x11</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">case</span> <span class="mh">0x00</span><span class="p">:</span> <span class="c1">// SW1 &amp; SW2 pressed
</span>    <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">=</span> <span class="n">LED_RED</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mh">0x01</span><span class="p">:</span> <span class="c1">// SW1 pressed only
</span>    <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">=</span> <span class="n">LED_BLUE</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mh">0x10</span><span class="p">:</span> <span class="c1">// SW2 pressed only
</span>    <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">=</span> <span class="n">LED_GREEN</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>  
</code></pre>
</div>

<hr />

<p><strong>10. الإنتظار في حلقة التكرار الى أن تحدث مقاطعة</strong></p>

<p>في main، سنستخدم الدالة interrupts_wait_for لوضع المعالج في حالة الإنتظار standby لحين حدوث مقاطعة:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">interrupts_wait_for</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>وبذلك يكون كامل الكود:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include "C:\ti\TivaWare_C_Series-2.1.4.178\inc\tm4c123gh6pm.h"
</span>
<span class="cp">#define SW2        (1&lt;&lt;0)
#define LED_RED    (1&lt;&lt;1)		
#define LED_BLUE   (1&lt;&lt;2)		
#define LED_GREEN  (1&lt;&lt;3)		
#define SW1        (1&lt;&lt;4)		
</span>
<span class="kt">void</span> <span class="n">portf_config_gpio</span>       <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">portf_config_interrupts</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">interrupts_disable</span>  <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">interrupts_enable</span>   <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">interrupts_wait_for</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">portf_config_gpio</span> <span class="p">();</span>
  <span class="n">portf_config_interrupts</span> <span class="p">();</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">interrupts_wait_for</span><span class="p">();</span>
  <span class="p">}</span>  
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">portf_config_gpio</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait</span><span class="p">;</span>
  
  <span class="c1">// 1) Enable clock for Port F
</span>  <span class="n">SYSCTL_RCGCGPIO_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>  
  <span class="n">wait</span> <span class="o">=</span> <span class="n">SYSCTL_RCGCGPIO_R</span><span class="p">;</span> 
    
  <span class="c1">// 2.1) Unlock PF0
</span>  <span class="n">GPIO_PORTF_LOCK_R</span> <span class="o">=</span> <span class="mh">0x4C4F434B</span><span class="p">;</span>
  
  <span class="c1">// 2.2) Allow changes to PF0
</span>  <span class="n">GPIO_PORTF_CR_R</span> <span class="o">=</span> <span class="n">SW2</span><span class="p">;</span>
  
  <span class="c1">// 3) Disable analog functions
</span>  <span class="n">GPIO_PORTF_AMSEL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SW2</span><span class="o">|</span><span class="n">LED_RED</span><span class="o">|</span><span class="n">LED_BLUE</span><span class="o">|</span><span class="n">LED_GREEN</span><span class="o">|</span><span class="n">SW1</span><span class="p">);</span>
	
  <span class="c1">// 4) Set pin direction
</span>  <span class="n">GPIO_PORTF_DIR_R</span>  <span class="o">=</span>  <span class="p">(</span><span class="n">LED_RED</span><span class="o">|</span><span class="n">LED_BLUE</span><span class="o">|</span><span class="n">LED_GREEN</span><span class="p">);</span> <span class="c1">// Output
</span>  <span class="n">GPIO_PORTF_DIR_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>                    <span class="c1">// Input
</span>  
  <span class="c1">// 5) disable alternate functions
</span>  <span class="n">GPIO_PORTF_AFSEL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SW2</span><span class="o">|</span><span class="n">LED_RED</span><span class="o">|</span><span class="n">LED_BLUE</span><span class="o">|</span><span class="n">LED_GREEN</span><span class="o">|</span><span class="n">SW1</span><span class="p">);</span>
  
  <span class="c1">// 6) Set pull up resistor
</span>  <span class="n">GPIO_PORTF_PUR_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span> 
  
  <span class="c1">// 7) Enable pins
</span>  <span class="n">GPIO_PORTF_DEN_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">SW2</span><span class="o">|</span><span class="n">LED_RED</span><span class="o">|</span><span class="n">LED_BLUE</span><span class="o">|</span><span class="n">LED_GREEN</span><span class="o">|</span><span class="n">SW1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">portf_config_interrupts</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1) Make PF4/PF0 edge sensitive
</span>  <span class="n">GPIO_PORTF_IS_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>
  
  <span class="c1">// 2) Single edges
</span>  <span class="n">GPIO_PORTF_IBE_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>
  
  <span class="c1">// 3) Falling-edge
</span>  <span class="n">GPIO_PORTF_IEV_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>

  <span class="c1">// 4) Clear any prior interrupt
</span>  <span class="n">GPIO_PORTF_ICR_R</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>
  
  <span class="c1">// 5) PortF is given priority 3
</span>  <span class="n">NVIC_PRI7_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">);</span> 
    
  <span class="c1">// 6) Enable interrupt for PortF (IRQ 30) in NVIC
</span>  <span class="n">NVIC_EN0_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span>
    
  <span class="c1">// 7) Enable interrupts for PF4, PF0
</span>  <span class="n">GPIO_PORTF_IM_R</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>
  
  <span class="c1">// 8) Global interrupts enable
</span>  <span class="n">interrupts_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GPIOF_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">readback</span><span class="p">;</span>
 
  <span class="c1">// clear interrupt
</span>  <span class="n">GPIO_PORTF_ICR_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">SW1</span><span class="o">|</span><span class="n">SW2</span><span class="p">);</span>       
  
  <span class="c1">// a read to force clearing of interrupt flag
</span>  <span class="n">readback</span> <span class="o">=</span> <span class="n">GPIO_PORTF_ICR_R</span><span class="p">;</span>
  
  <span class="c1">// toggle LEDs   
</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">GPIO_PORTF_DATA_R</span> <span class="o">&amp;</span> <span class="mh">0x11</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mh">0x00</span><span class="p">:</span> <span class="c1">// SW1 &amp; SW2 pressed
</span>      <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">=</span> <span class="n">LED_RED</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    
    <span class="k">case</span> <span class="mh">0x01</span><span class="p">:</span> <span class="c1">// SW1 pressed only
</span>      <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">=</span> <span class="n">LED_BLUE</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    
    <span class="k">case</span> <span class="mh">0x10</span><span class="p">:</span> <span class="c1">// SW2 pressed only
</span>      <span class="n">GPIO_PORTF_DATA_R</span> <span class="o">=</span> <span class="n">LED_GREEN</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>  
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">interrupts_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__asm</span> <span class="p">(</span><span class="s">"CPSID  I</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">interrupts_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__asm</span>  <span class="p">(</span><span class="s">"CPSIE  I</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">interrupts_wait_for</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">__asm</span>  <span class="p">(</span><span class="s">"WFI</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
</div>

</p>

    <blockquote class="post_ending_note">
        <p><strong>ملاحظة</strong>: هذه المقالة تحت التحديث المستمر،، وملاحظاتكم وإقتراحاتكم ستساعد بإذن الله في إخراجها بالصورة التي كتبت من أجلها وهي تمهيد الطريق أمامكم لتعلم برمجة الأنظمة المدمجة </p>
    </blockquote>

    <hr>
      
          <a class="prev" href="/2018/09/11/ADC.html">14. المُقاطعات  Interrupts</a> <br>
      
      
          <a class="next" href="/2018/08/17/i2c.html">13. بروتوكول الإتصال المتزامن I2C</a> <br>
      
    <br>
    <hr>

<br>




<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = "http://localhost:4000/2018/09/10/interrupts.html";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/2018/09/10/interrupts"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://embedded-course.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            


      </section>
<!--      
      <footer>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
-->
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    <!--<script type="text/javascript" src="/assets/js/staticman.js"></script>-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-106571814-1', 'auto');
        ga('send', 'pageview');
    </script>
  
  </body>
</html>
