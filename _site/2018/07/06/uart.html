<!doctype html>
<html dir="rtl" lang="ar-SA">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>بروتوكول الإتصال الغير متزامن UART | لنتعلم برمجة الأنظمة المدمجة</title>
<meta property="og:title" content="بروتوكول الإتصال الغير متزامن UART" />
<meta name="author" content="خالد الغامدي" />
<meta property="og:locale" content="ar_SA" />
<meta name="description" content="في هذا الدرس، سنجعل المتحكم يتواصل مع أجهزة أخرى مثل أجهزة الكمبيوتر وشاشات LCD ومتحكمات أخرى حيث يمكننا القيام بذلك باستخدام إما طريقة الاتصال المتوازي parallel communication أو الإتصال المتسلسل serial communication." />
<meta property="og:description" content="في هذا الدرس، سنجعل المتحكم يتواصل مع أجهزة أخرى مثل أجهزة الكمبيوتر وشاشات LCD ومتحكمات أخرى حيث يمكننا القيام بذلك باستخدام إما طريقة الاتصال المتوازي parallel communication أو الإتصال المتسلسل serial communication." />
<link rel="canonical" href="http://localhost:4000/2018/07/06/uart.html" />
<meta property="og:url" content="http://localhost:4000/2018/07/06/uart.html" />
<meta property="og:site_name" content="لنتعلم برمجة الأنظمة المدمجة" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-06T00:00:00+03:00" />
<script type="application/ld+json">
{"name":null,"description":"في هذا الدرس، سنجعل المتحكم يتواصل مع أجهزة أخرى مثل أجهزة الكمبيوتر وشاشات LCD ومتحكمات أخرى حيث يمكننا القيام بذلك باستخدام إما طريقة الاتصال المتوازي parallel communication أو الإتصال المتسلسل serial communication.","author":{"@type":"Person","name":"خالد الغامدي"},"@type":"BlogPosting","url":"http://localhost:4000/2018/07/06/uart.html","publisher":null,"image":null,"headline":"بروتوكول الإتصال الغير متزامن UART","dateModified":"2018-07-06T00:00:00+03:00","datePublished":"2018-07-06T00:00:00+03:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/07/06/uart.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script type="text/javascript" src="/assets/js/jquery-1.12.4.min.js" ></script>
    <script type="text/javascript" src="/assets/js/main.js"></script>
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>لنتعلم برمجة الأنظمة المدمجة</h1>
		<h3 text-align="left">Embedded Systems Programming Bootcamp</h3>
        <p>كورس تعليمي يهدف الى اكسابك المعرفة اللازمة والمهارات التقنية المتعلقة ببرمجة وتطوير الأنظمة المدمجة وفهم خصائصها ومكوناتها</p>
        <p class="view">
            <a href="/">الصفحة الرئيسية</a><br>
            <!--<a href="/#contents">الدروس</a><br>-->
            <a href="/lessons.html">قائمة الدروس</a><br>
            <a href="/feed.xml" title="Subscribe to our RSS feed">خدمة RSS</a>
        </p>
        <!--/assets/images/sidebar/rss.svg-->
          <!--<aside>-->
    <h3>للتواصل</h3>
    <ul class="social">
    <li><a href="https://github.com/alhabish/embedded-course" title="Github" class="github">Github</a></li>
    <li><a href="mailto:alhabish@gmail.com" title="Email" class="mail">Email</a></li>
    <li><a href="https://www.linkedin.com/in/khalidalghamidi" title="Linked in" class="linked">LinkedIn</a></li>
    <li><a href="http://www.twitter.com/alhabish" title="Twitter" class="twitter">Twitter</a></li>
    </ul>
    <!--</aside>-->
          
<!--        
        

        

        
-->
      </header>
      <section>

      <h1>11. بروتوكول الإتصال الغير متزامن UART</h1>
<p class="meta">2018-07-06</p>


<!-- from https://github.com/cstack/db_tutorial -->


      
      

    <hr>
      
          <a class="prev" href="/2018/07/18/spi.html">12. بروتوكول الإتصال المتزامن SPI</a> <br>
      
      
          <a class="next" href="/2018/06/20/pll.html">10. Phased Lock Loop - PLL</a> <br>
      
    <br>
    <hr>

    <p><p>في هذا الدرس، سنجعل المتحكم يتواصل مع أجهزة أخرى مثل أجهزة الكمبيوتر  وشاشات LCD ومتحكمات أخرى حيث يمكننا القيام بذلك باستخدام إما طريقة الاتصال المتوازي parallel communication أو الإتصال المتسلسل serial communication.</p>

<p>في الاتصال المتوازي parallel، يتم نقل بتات متعددة في الوقت ذاته بينما في الاتصال المتسلسل serial نرسل البتات واحدة تلو الأخرى.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/serial_vs_parallel.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/serial_vs_parallel.png');" />
    </td>
</tr>
</table>

<p>الدافع وراء استخدام الإتصال المتسلسل هو إستخدام عدد أقل من الأطراف pins. حيث أنه إذا أردنا نقل قيمة مكونة من 8 بت باستخدام الإتصال المتوازي سنحتاج إلى 8 أطراف pins لإرسال هذه القيمة مما سيؤدي بطبيعة الحال الى زيادة حجم المتحكم وزيادة التعقيد في توصيل هذا المتحكم بأجهزة أخرى. بينما في الإتصال المتسلسل serial نستخدم عدد أقل من الأطراف pins مما يجعل من تطوير لوحة الدوائر المطبوعة (PCB) أسهل بكثير وأقل كلفة وعرضة للأخطاء.</p>

<p>وبالرغم من أنه في الإتصال المتسلسل يتم إرسال البتات الواحد تلو الآخر الا أن هذا لا يمنعنا من نقل بيانات بأي حجم كانت. فلو كان حجم البيانات التي يمكن إرسالها في المرة الواحدة تساوي 8 بت مثلاً وكنا بحاجة الى إرسال 32 بت، فكل ما علينا فعله ببساطة هو إرسال هذه القيم بشكل متتالي أي 8 بت في كل مرة الى أن يتم إرسال البيانات بشكل كامل.</p>

<p>بعض الأمثلة على الاتصال المتسلسل هي UART، SPI ،I2C وسيغطي هذا الدرس بروتوكول الـ UART ولاحقاَ بمشيئة الله سوف نغطي البروتوكولات الأخرى.</p>

<hr />

<h2><a href=""></a> Universal Asynchronous Receiver and Transmitter - UART</h2>

<p>عند ربط أكثر من جهاز معاً، نحتاج إلى طريقة لمزامنتها مع بعضها البعض، أي أن يكون كل جهاز على علم ومعرفة بحالة الآخر. وما نقصده فعلياً بالتزامن هنا هو جعل السرعة بين الأجهزة المختلفة والمتصلة معاً متوافقة في السرعة مع بعضها البعض.</p>

<p>يجب هنا التوضيح بأن كلمة Asynchronous في UART يعني أن بروتوكول الإتصال هذا لا يتضمن وجود ساعة مشتركة بين الأجهزة، إذن كيف يحدث التزامن؟  يكون ذلك عن طريق إتفاق الجهاز المرسل والمستقبل على سرعة نقل معينة Baud Rate أو سرعة نقل البت في الثانية (بت/ثانية) وبذلك يعرف الجهاز المتلقي متى يتم تسجيل بداية ونهاية البيانات المنقولة.</p>

<p>فلو قلنا أننا ننقل البيانات بسرعة 9600 بت/ثانية فهذا يعني أن كل بت يستغرق 1/9600 أي تقريباً 104 مايكروثانية لنقله.</p>

<p>فيما يخص الهاردوير، فإن ما نحتاجه لتوصيل جهازين باستخدام الـ UART هو الوصلات التالية:</p>

<ul>
  <li>طرف الإتصال <strong>Tx</strong> (إرسال transmit) من <strong>(أ)</strong> والذي يتصل بالطرف <strong>Rx</strong> (إستقبال receive) في <strong>(ب)</strong></li>
  <li>طرف الإتصال <strong>Rx</strong> (إستقبال receive) من <strong>(أ)</strong> والذي يتصل بالطرف <strong>Tx</strong> (إرسال transmit) في <strong>(ب)</strong></li>
  <li>الطرف <strong>GND</strong> (أرضي ground) بين <strong>(أ)</strong> و <strong>(ب)</strong></li>
</ul>

<p>الهدف من إيصال الطرف الأرضي في كلا الجهازين هو الحفاظ على مرجع الجهد (reference voltage) لكلا الجهازين وذلك لأن الإشارات في الـ UART تتكون من إشارات ذات مستوى منخفض 0 ومستوى عال 1 ويجب على الجهاز المستقبِل أن يكون مدركًا إن كانت الإشارات المستقبلة منخفضة أم عالية.</p>

<table style="border: 1px solid #CACFD2">

<caption align="bottom" style="text-transform: lowercase; font-style: italic; font-size: 0.8em">source: https://learn.sparkfun.com/tutorials/serial-communication</caption>
<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/uart_connections.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/uart_connections.png');" />
    </td>
</tr>
</table>

<hr />

<h2><a href=""></a> هيكل الرسالة  Message Frame</h2>

<p>تتكون رسالة الـ UART من البتات التالية:</p>

<ul>
  <li>
    <p>بت البداية <strong>start bit</strong> وتعني بأن المرسل جاهز لنقل البيانات</p>
  </li>
  <li>
    <p>بتات البيانات <strong>data bits</strong> وتتكون من 8 بت.</p>
  </li>
  <li>
    <p>بت التوازن <strong>parity bit</strong> وهي اختيارية. وتستخدم للكشف عن الأخطاء error detection وليس لتصحيحها error correction ولن يتم التطرق لها في هذا الدرس.</p>
  </li>
  <li>
    <p>بت التوقف <strong>stop bit</strong> (ومن الممكن أن تتكون من 2 بت) وهي توضح بأن البيانات قد تم نقلها بشكل كامل.</p>
  </li>
</ul>

<p>وبناءً على ذلك يتضح لنا أنه لكل بايت byte من البيانات التي نريد نقلها فإنه يتم أيضًا نقل بعض البتات الإضافية.</p>

<p>هناك عدة أشكال للرسالة في الـ UART. فمن الممكن أن تكون بتات البيانات 5 أو 6 أو 7 أو 8 بتات. ومن الممكن أن يكون لدينا أيضًا بت التوازن parity bit أو لا. ويمكن أن يكون لدينا إما 1 أو 2 بت توقف.</p>

<p>ولكننا في هذا الدرس سنستخدم الهيكل الافتراضي default للرسالة وهي:</p>

<ul>
  <li>1 بت للبدء</li>
  <li>8 بتات للبيانات (بايت byte)</li>
  <li>0 بت للتوازن</li>
  <li>1 بت للتوقف</li>
</ul>

<p>وبذلك يكون لدينا ما مجموعه 10 بتات لكل بايت byte من البيانات التي نرغب في إرسالها حيث أن 8 بتات مخصصة للبيانات، و 2 بتات إحداهما للبداية والآخر للتوقف.</p>

<table style="border: 1px solid #CACFD2">

<caption align="bottom" style="text-transform: lowercase; font-style: italic; font-size: 0.8em">source: https://courses.edx.org/courses/course-v1:UTAustinX+UT.6.20x+2T2018</caption>
<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/frame.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/frame.png');" />
    </td>
</tr>
</table>

<hr />

<h2><a href=""></a> نقل الرسالة Transmiting a Frame</h2>

<p>كل بايت byte نوّد إرساله يوضع وسط إطار يبدأ ببت البداية start bit وينتهي ببت التوقف stop bit. وهذه العملية تسمى التأطير framing.</p>

<p>دعونا نرسل الحرف ‘K’ كمثال.</p>

<p>نجد أنه في جدول الـ ASCII:</p>

<p><a href="https://www.asciitable.com">https://www.asciitable.com</a></p>

<p>يتكون هذا الحرف من الرقم الست عشري والرقم الثنائي التالي:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>'K' = 0x4B = 0100 1011
</code></pre>
</div>

<p>وبذلك ستكون خطوات الإرسال كالآتي:</p>

<ol>
  <li>
    <p>تكون إشارة UART في حالة الخمول idle (عندما لا يكون هناك نقل للبيانات) وتظل عالية (1) عند 3.3 فولت.</p>
  </li>
  <li>
    <p>عندما نكون مستعدين لبدء الإرسال، يتم إسقاط خط Tx الى الوضع المنخفض (0) لمدة 1 بت وهذا يعتبر بت البداية start bit.</p>
  </li>
  <li>
    <p>بعد ذلك يتم وضع بتات البيانات في الرسالة بدءاً من الـ least significant bit أو lsb وهي 1 هنا وإنتهاءاً بالـ most significant bit أو msb وهي 0 في مثالنا.</p>
  </li>
  <li>
    <p>بعد ذلك يعود خط Tx الى الحالة العالية 1 وذلك يعني أننا أنتهينا من الرسالة وعدنا الى حالة الخمول idle state.</p>
  </li>
</ol>

<p>هذا يعني أنه سيتم إرسال الرسالة على النحو التالي:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/k.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/k.png');" />
    </td>
</tr>
</table>

<p>يمكنك بعد ذلك البدء في إرسال رسائل أخرى إن أردت كأن يكون لديك عبارة أو كلمة تود إرسالها مثل “Khalid” فبعد إرسال الحرف الأول K ستقوم بالمرور على بقية الحروف وإرسالها بشكل متتالي.</p>

<hr />

<h2><a href=""></a> التواصل بين جهاز الكمبيوتر والمتحكم</h2>

<p>سوف نجعل المتحكم يتواصل مع الكمبيوتر من خلال الـ UART.  ولعمل ذلك نحن بحاجة الى محول من USB إلى UART والعكس لتحويل البيانات من منفذ USB إلى بيانات UART. هذا المنفذ موجود في البورد ولسنا بحاجة الى إستخدام مكونات إضافية.</p>

<p>في بورد TI LaunchPad المستخدم، نجد أن منفذ UART0 في المتحكم TM4C123GH6PM متصل بمتحكم آخر وهو متحكم المصحح debugger في أعلى البورد والتي تعمل كجسر بين الـ USB والـ UART. عندما نوصل الـ Tiva LaunchPad بالكمبيوتر عن طريق الـ USB، يكون ذلك من جهة البورد عن طريق UART0 وفي الكمبيوتر يكون هنالك اتصال إفتراضي virtual connection كمنفذ COM أو COM port.</p>

<p>ويمكن الإطلاع على مخرجات الـ UART على جهاز الكمبيوتر عن طريق برامج مثل Putty و Tera Term وغيرها من البرامج الطرفية terminals. مع الأخذ بالإعتبار الى أن هناك حاجة لضبط إعدادات هذه البرامج لتصبح تماماً مثل تلك التي تم تحديدها في البرنامج على المتحكم.</p>

<p>إفتح Device Manager وتحت القائمة Ports (COM &amp; LPT) ستجد Stellaris Virtual Serial Port (COMn) علماً أن n هنا من الممكن أن تكون أي رقم وذلك يعتمد على تعيين Windows للمنافذ:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/device_manager.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/device_manager.png');" />
    </td>
</tr>
</table>

<p>إنقر عليها باليمين ثم إختر Properties. إختر تبويب Port Settings في النافذه الظاهرة وتأكد أن لديك الإعدادات التالية:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/port_settings.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/port_settings.png');" />
    </td>
</tr>
</table>

<p>إضغط على OK لقفل النافذه.</p>

<p>حمل برنامج Tera Term من الرايط التالي:</p>

<p><a href="https://osdn.net/projects/ttssh2/releases/">https://osdn.net/projects/ttssh2/releases/</a></p>

<p>وبعد تشغيله إختر Serial والـ port الخاص بـ Stellaris Virtual Serial Port:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/teraterm_new_connection.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/teraterm_new_connection.png');" />
    </td>
</tr>
</table>

<p>إضغط على OK لقفل النافذه.</p>

<p>من القائمة الرئيسية في البرنامج إختر Setup ومن ثم Serial Port من القائمة المنسدلة:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/teraterm_setup.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/teraterm_setup.png');" />
    </td>
</tr>
</table>

<p>تأكد أن لديك نفس الإعدادات التالية:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/teraterm_serial_port_setup.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/teraterm_serial_port_setup.png');" />
    </td>
</tr>
</table>

<p>إضغط على OK ليبدأ البرنامج بالعمل بالإعدادات الجديدة.</p>

<hr />

<h2><a href=""></a> تهيئة الـ UART</h2>

<p>إذا فتحنا صفحة 902 في دليل البيانات، فإنه بإمكاننا العثور على الخطوات المطلوبة لتهيئة الـ UART وهي:</p>

<p><strong>1. قم بتمكين وحدة الـ UART باستخدام سجل RCGCUART (راجع صفحة 344).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/RCGCUART.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/RCGCUART.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define SYSCTL_RCGCUART_R    (*((volatile unsigned long *)0x400FE618))
</span></code></pre>
</div>

<p>يتحكم الحقل R0 (بت 0) في ساعة UART0 التي سنستخدمها. وسيؤدي تعيين القيمة 1 الى هذا الحقل إلى تمكين UART0.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">SYSCTL_RCGCUART_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0x01
</span></code></pre>
</div>

<p><strong>2. قم بتمكين ساعة وحدة الـ GPIO المناسبة عبر سجل RCGCGPIO (انظر صفحة 340). لمعرفة أي منفذ GPIO يجب عليك تمكينه، راجع الجدول 5-23 في الصفحة 1351.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/RCGCGPIO.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/RCGCGPIO.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define SYSCTL_RCGCGPIO_R    (*((volatile unsigned long *)0x400FE608))
</span></code></pre>
</div>

<p>لنذهب لصفحة 1351 لنرى أي منفذ GPIO يجب علينا تفعيله:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/table_23_5.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/table_23_5.png');" />
    </td>
</tr>
</table>

<p>يمكننا أن نرى أن UART0 يستخدم المنفذ  PORT A. الطرف PA0 لتلقي البيانات Rx والطرف PA1 لنقل البيانات Tx. وبالعودة إلى سجل RCGCGPIO، يتضح أنه لتمكين PORT A علينا تعيين 1 إلى الحقل R0 (بت 0)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">SYSCTL_RCGCGPIO_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0x01;
</span></code></pre>
</div>

<p><strong>3. ﻗﻢ ﺑﻀﺒﻂ بتات GPIOAFSEL ﻟلأطراف ﺍﻟﻤﻨﺎﺳﺒﺔ (ﺍﻧﻈﺮ ﺻﻔﺤﺔ ٦٧١). لتحديد أي GPIO يجب علينا ضبط إعداداته، راجع جدول 4-23 في الصفحة 1344.</strong></p>

<p>يمكن العثور على تفاصيل سجل GPIOAFSEL في صفحة 671:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/GPIOAFSEL.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/GPIOAFSEL.png');" />
    </td>
</tr>
</table>

<p>وسبق وأن حددنا المنفذ الذي سنتعامل معه وهو PORT A.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define GPIO_PORTA_AFSEL_R    (*((volatile unsigned long *)0x40004420))
</span></code></pre>
</div>

<p>لتمكين الوظائف البديلة لـلمنافذ PA0 و PA1، نقوم بإسناد 1 الى بت 0 وبت 1 في حقل AFSEL</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTA_AFSEL_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0x03
</span></code></pre>
</div>

<p>إسناد القيمة 1 في سجل AFSEL يقوم بتمكين الوظيفة البديلة للطرف pin. الا أن هذا في حد ذاته لا يكفي حيث أن بعض الأطراف تدعم أكثر من وظيفة بديلة واحدة. وهنا ياتي دور سجل التحكم في المنفذ (PCTL) والذي نقوم فيه بتحديد بالضبط ماهي الوظيفة البديلة التي سيقوم بها المنفذ.</p>

<p><strong>4. قم بتهيئة مستوى التيار لـ GPIO و / أو معدل slew كما هو محدد للوضع المختار (راجع صفحة 673 وصفحة 681).</strong></p>

<p>يمكننا تجاهل هذه الخطوة في الوقت الحالي.</p>

<p><strong>5. قم بضبط إعدادات حقول PMCn في سجل GPIOPCTL لتعيين إشارات UART إلى الأطراف المناسبة (انظر صفحة 688 والجدول 5-23 في الصفحة 1351).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/GPIOPCTL.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/GPIOPCTL.png');" />
    </td>
</tr>
</table>

<p>نستخدم السجل register التالي للمنفذ PORT A:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define GPIO_PORTA_PCTL_R    (*((volatile unsigned long *)0x4000452C))
</span></code></pre>
</div>

<p>بمجرد تمكيننا للوظائف البديلة، يتعين علينا عندئذ اختيار الوظيفة البديلة المحددة التي نريدها. في الجدول 5-23 في صفحة 1351 في دليل البيانات يمكننا رؤية أن UART0 يقع في العمود 1:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/uart0.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/uart0.png');" />
    </td>
</tr>
</table>

<p>هذا يعني أنه يجب أن نضع 1 في بت PMCn. لذلك نذهب إلى سجل GPIOPCTL (ص 689) والذي يحتوي على بت PMCn. ويمثل PMC0 (البتات 0-3) الطرف PA0 لذلك علينا أن نضع 1 فيها. ويمثل PMC1 (بت 4-7) الطرف PA1 وعلينا أيضا أن نضع 1 فيه أيضاً.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTA_PCTL_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 0x11
</span></code></pre>
</div>

<p>وبما أنها إشارات رقمية فإنه يجب علينا تمكين الوظائف الرقمية للأطراف:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define GPIO_PORTA_DEN_R    (*((volatile unsigned long *)0x4000451C))
</span></code></pre>
</div>

<p>وهذا يكون كالتالي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTA_DEN_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 0x03; // enable digital I/O on PA1-0
</span></code></pre>
</div>

<hr />

<h2><a href=""></a> ضبط إعدادات الـ UART</h2>

<p>الإعدادات التي سنضبط الـ UART عليها هي كما يلي:</p>

<ul>
  <li>تردد الساعة 16 ميجاهرتز</li>
  <li>معدل نقل البيانات baud rate تساوي 9600 بت/ثانية</li>
  <li>حجم البيانات data bits المنقولة 8 بت</li>
  <li>بت توقف stop bit واحد</li>
  <li>لا يوجد بت توازن parity bit</li>
  <li>تم تمكين الـ FIFO</li>
  <li>لن نستخدم المقاطعات interrupts</li>
</ul>

<p>أول شيء يجب مراعاته عند برمجة الـ UART هو إيجاد مقسوم معدل نقل البيانات baud-rate divisor (BRD). باستخدام المعادلة الموضحة في “Baud-Rate Generation” في صفحة 896، يمكن حساب BRD باستخدام المعادلة التالية:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Baud Rate = SysClk / (16 × ClkDiv)
</code></pre>
</div>

<p>حيث أن:</p>

<ul>
  <li><em>SysCLK</em> هي تردد ساعة النظام المستخدمة والمتصلة بـالـ UART و</li>
  <li><em>ClkDiv</em> هي سرعة نقل البيانات المختارة</li>
</ul>

<p>وبالتالي يكون لدينا:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>BRD = 16,000,000 / (16 * 9600) = 104.1666666666667
</code></pre>
</div>

<p>وسيتم إحتساب الكسر كما يلي:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>UARTFBRD[DIVFRAC] = integer(0.1666666666667 * 64 + 0.5) = 11
</code></pre>
</div>

<p>وبعد أن حصلنا على قيمة BRD، نضبط إعدادات الـ UART بالترتيب التالي:</p>

<p><strong>1. قم بتعطيل UART عن طريق مسح (إسناد 0) الحقل UARTEN (بت 0) في سجل UARTCTL (ص 918).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTCTL.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTCTL.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_CTL_R   (*((volatile unsigned long *)0x4000C030))
</span></code></pre>
</div>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">UART0_CTL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// ~(0x00000001);
</span></code></pre>
</div>

<p><strong>2. اكتب العدد الصحيح من الـ BRD إلى سجل UARTIBRD (ص 914).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTIBRD.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTIBRD.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_IBRD_R   (*((volatile unsigned long *)0x4000C024))
</span></code></pre>
</div>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">UART0_IBRD_R</span> <span class="o">=</span> <span class="mi">104</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>3. اكتب الكسر من الـ BRD إلى سجل UARTFBRD (ص 915).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTFBRD.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTFBRD.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_FBRD_R   (*((volatile unsigned long *)0x4000C028))
</span></code></pre>
</div>

<p>يتكون سجل UARTIBRD من 32 بت، نستخدم منها أول 16 بت. وبالنسبة للسجل UARTFBRD فيتم استخدام أول 6 بتات فقط. وهذا يعطينا ما مجموعه 22 بت (16 بت للعدد الصحيح + 6 بت للكسر).</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">UART0_FBRD_R</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>4. اكتب قيم الإعدادات المطلوبة للـ UART في سجل UARTLCRH (ص 916).</strong></p>

<p>هذا هو السجل الذي نستخدمه لضبط عدد البتات لكل حرف يتم إرساله (طول البيانات data bits) وعدد بتات التوقف stop bits الإضافة الى إعدادت أخرى.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTLCRH.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTLCRH.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_LCRH_R   (*((volatile unsigned long *)0x4000C02C))
</span></code></pre>
</div>

<p>نريد هنا إسناد القيمة 0x3 الى الحقل WLEN (بت 5-6) حيث أن عدد بتات البيانات data bits التي سنرسلها هو 8 بت.</p>

<p>تحتوي وحدة الـ UART  في TI Tiva على مخزن مؤقت FIFO داخلي بحجم 16 بايت لتخزين البيانات المعدة للإرسال. ويوجد أيضاً مخزن FIFO آخر بحجم 16 بايت أيضاً لحفظ البايتات bytes المتلقاة. ومن خلال إسناد 1 الى الحقل FEN (بت 4) سنقوم بتمكين الـ FIFO والذي يمكننا من كتابة ما يصل إلى 16 بايت للـ UART وستقوم من ذاتها بإرسال بايت تلو الآخر الى أن تصبح الـ FIFO فاضية. كما أن الـ FIFO للبيانات المتلقاه تمكن الـ UART من استقبال 16 بايت بينما يقوم برنامجنا بالتعامل مع الواحدة تلو الأخرى.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">UART0_LCRH_R</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x3</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span>
</code></pre>
</div>

<p><strong>5. قم بإعداد مصدر ساعة الـ UART بالكتابة إلى سجل UARTCC (ص 939).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTCC.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTCC.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_CC_R   (*((volatile unsigned long *)0x4000CFC8))
</span></code></pre>
</div>

<p>في حقل CS (بت 0-3) نحدد مصدر ساعة الـ UART. حيث نقوم بإسناد القيمة 0x0 الى الحقل لإختيار ساعة النظام System Clock.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">UART0_CC_R</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>6. هذه الخطوة إختيارية، قم بإعداد قناة MicroDMA (راجع “Micro Direct Memory Access (MicroDMA)” في صفحة 585) وقم بتمكين خيارات الـ DMA في سجل UARTDMACTL.</strong></p>

<p>سنتجاهل هذه الخطوة.</p>

<p><strong>7. قم بتمكين الـ UART عن طريق إسناد 1 الى حقل UARTEN (بت 0) في سجل UARTCTL (ص 918).</strong></p>

<p>يمكن العثور على تفاصيل هذا السجل في الخطوة الأولى.</p>

<p>سنقوم بإسناد 1 الى حقل UARTEN (بت 0) لتمكين الـ UART. وسنقوم أيضًا بإسناد 1 الى حقل TXE (بت 8) وحقل RXE (بت 9) لتمكين UART من الإرسال والإستقبال</p>

<div class="highlighter-rouge"><pre class="highlight"><code>UART0_CTL_R  = (1&lt;&lt;0)|(1&lt;&lt;8)|(1&lt;&lt;9);
</code></pre>
</div>

<hr />

<h2><a href=""></a> إرسال البيانات</h2>

<table style="border: 1px solid #CACFD2">

<caption align="bottom" style="text-transform: lowercase; font-style: italic; font-size: 0.8em">source: http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C11_Interactives.htm</caption>
<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/tx.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/tx.png');" />
    </td>
</tr>
</table>

<p>لإرسال بايت byte من البيانات فإنه يجب وضعه في سجل البيانات UARTDR. وعلى الرغم من أنه سجل من 32 بت، الا إنه سيتم استخدام أول 8 بت فقط (بت 0-7).</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTDR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTDR.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_DR_R   (*((volatile unsigned long *)0x4000C000))
</span></code></pre>
</div>

<p>ولكن، قبل ذلك فإننا نقوم بمراقبة الحقل TXFF (بت 5) في السجل UARTFR:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/UARTFR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/UARTFR.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define UART0_FR_R   (*((volatile unsigned long *)0x4000C018))
</span></code></pre>
</div>

<p>ويكون ذلك قبل الكتابة الى UARTDR وطالما كانت قيمة TXFF تساوي 1 فهذا يعني أن الـ FIFO ممتلئ ولا يمكنه قبول أي بيانات أخرى وأنه يجب علينا أن نتنتظر. وعندما تصبح القيمة 0 فهذا يعني أن المخزن المؤقت للإرسال FIFO غير ممتلئ وبإمكاننا الكتابة اليه ونقوم عندئذ بكتابة بايت إلى السجل UARTDR والذي سيضعها في الـ FIFO ليتم إرسالها.</p>

<p>بعد الكتابة الى سجل البيانات UARTDR، يتم تمرير هذه البتات الثمانية إلى الـ  FIFO وهو عبارة عن مخزن مؤقت للرسائل مكون من 16 عنصر يمكن البرنامج من كتابة العديد من البيانات اليها ليتم إرسالها الواحدة تلو الأخرى فيما بعد.</p>

<p>بعد ذلك يتم تحميل العناصر الموجودة في الـ FIFO إلى shift register من 10 بتات متصل بطرف الإرسال Tx. وعندما يحين وقت الإرسال سيتم إرسال البتات كما يلي:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/message.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/message.png');" />
    </td>
</tr>
</table>

<p>وبذلك يكون الكود:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">((</span><span class="n">UART0_FR_R</span> <span class="o">&amp;</span> <span class="mh">0x0020</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>      	
<span class="n">UART0_DR_R</span> <span class="o">=</span> <span class="sc">'K'</span><span class="p">;</span>
</code></pre>
</div>

<hr />

<h2><a href=""></a> إستقبال البيانات</h2>

<table style="border: 1px solid #CACFD2">

<caption align="bottom" style="text-transform: lowercase; font-style: italic; font-size: 0.8em">source: http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C11_Interactives.htm</caption>
<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_11/rx.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_11/rx.png');" />
    </td>
</tr>
</table>

<p>بالنسبة للإستقبال فإن العملية ستحدث بالعكس. سيستقبل الـ shift register المتصل بخط الإستقبال Rx الرسالة وسيضعها لك في الـ FIFO لتتمكن من قرائتها عن طريق السجل UARTDR.</p>

<p>ولكن، وقبل قراءة السجل UARTDR فإنه يجب علينا التأكد من أن الـ FIFO ليس فارغاً بل يحمل بيانات لنا لقرائتها. وعلى ذلك، سنقوم بالتحقق من قيمة الحقل RXFE  (بت 4) في السجل UARTFR. فطالما كانت القيمة المعادة هي 1 فهذا يعني أنه لا توجد رسائل مستقبلة وسيدخل البرنامج في عملية انتظار دائم busy wait الى أن تصبح القيمة 0. وعندما تصبح القيمة المعادة 0، فهذا يعني أن هناك على الأقل بعض البيانات البيانات التى بإمكاننا قرائتها.</p>

<p>البتات الـ 8 الأولى (بت 0-7) في UARTDR ستحتوي على البايت المستقبل. وتستخدم 4 بتات إضافية أخرى من 8 الى 11 للكشف عن الأخطاء. ويوجد سجلان آخران وهما UARTRSR و UARTRCR يمكن إستخدامها للتأكد من مصدر المشكلة.</p>

<p>وفيما يلي الكود المستخدم لإستقبال الرسائل من الـ UART:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">UART1_FR_R</span> <span class="o">&amp;</span> <span class="mh">0x0010</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>     
<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">UART0_DR_R</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
</code></pre>
</div>

<p>يوجد شرح تفاعلي رائع يوضح عملية الإرسال والإستقبال في الـ UART على الرابط التالي:</p>

<p><a href="http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C11_Interactives.htm#ITool11.4">http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C11_Interactives.htm#ITool11.4</a></p>

<hr />

<h2><a href=""></a> البرنامج</h2>

<p>البرنامج التالي يقوم ببساطة بتمكبن المستخدم من إرسال حرف يدخله عن طريق برنامج Tera Term وسيتم إرساله الى المتحكم عن طريق UART0 ومن ثم إعادة إرساله أيضاً عن طريق UART0 الى جهاز الكمبيوتر ليتم طباعته.</p>

<p><em>لا تنسى بعد كتابة البرنامج الى المتحكم الضغط عل زر Reset على البورد ليبدأ البرنامج بالتنفيذ.</em></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define SYSCTL_RCGCUART_R     (*((volatile unsigned long *)0x400FE618))
#define SYSCTL_RCGCGPIO_R     (*((volatile unsigned long *)0x400FE608))
#define GPIO_PORTA_AFSEL_R    (*((volatile unsigned long *)0x40004420))
#define GPIO_PORTA_PCTL_R     (*((volatile unsigned long *)0x4000452C))
#define GPIO_PORTA_DEN_R      (*((volatile unsigned long *)0x4000451C))
#define UART0_CTL_R           (*((volatile unsigned long *)0x4000C030))
#define UART0_IBRD_R          (*((volatile unsigned long *)0x4000C024))
#define UART0_FBRD_R          (*((volatile unsigned long *)0x4000C028))
#define UART0_LCRH_R          (*((volatile unsigned long *)0x4000C02C))
#define UART0_CC_R            (*((volatile unsigned long *)0x4000CFC8))
#define UART0_DR_R            (*((volatile unsigned long *)0x4000C000))
#define UART0_FR_R            (*((volatile unsigned long *)0x4000C018))
</span>
<span class="kt">void</span> <span class="n">uart0_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">uart0_in_char</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uart0_out_char</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uart0_out_string</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">(</span> <span class="p">){</span>
  <span class="n">uart0_init</span><span class="p">();</span>

  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">){</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">uart0_in_char</span><span class="p">();</span>  <span class="cm">/* receive char */</span>
    <span class="n">uart0_out_char</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>    <span class="cm">/* echo received char */</span>
  <span class="p">}</span>
	
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Call only once
</span><span class="kt">void</span> <span class="n">uart0_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="c1">// -------------------------------- //
</span>	<span class="c1">// 	Initialize the UART module  //
</span>	<span class="c1">// -------------------------------- //
</span>	
	<span class="c1">// 1. Enable the UART module using the RCGCUART register (see page 344).
</span>	<span class="n">SYSCTL_RCGCUART_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0x01 // enable UART 0
</span>	
	<span class="c1">// 2. Enable the clock to the appropriate GPIO module via the RCGCGPIO register (see page 340).
</span>	<span class="c1">// To find out which GPIO port to enable, refer to Table 23-5 on page 1351.	
</span>	<span class="n">SYSCTL_RCGCGPIO_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0x01 // enable PORT A
</span>	
	<span class="c1">// 3. Set the GPIO AFSEL bits for the appropriate pins (see page 671). To determine which GPIOs to
</span>	<span class="c1">// configure, see Table 23-4 on page 1344.
</span>	<span class="n">GPIO_PORTA_AFSEL_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 0x03 // enable alternate functions on PA1-0
</span>	
	<span class="c1">// 4. Configure the GPIO current level and/or slew rate as specified for the mode selected (see
</span>	<span class="c1">// page 673 and page 681).
</span>	
	<span class="c1">// No need to worry about this for now
</span>		
	<span class="c1">// 5. Configure the PMCn fields in the GPIOPCTL register to assign the UART signals to the appropriate
</span>	<span class="c1">// pins (see page 688 and Table 23-5 on page 1351).
</span>	<span class="n">GPIO_PORTA_PCTL_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 0x11 // configure PA1-0 as UART0	
</span>	<span class="n">GPIO_PORTA_DEN_R</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 0x03 // enable digital I/O on PA1-0
</span>	
	<span class="c1">// ------------------------------- //
</span>	<span class="c1">// 	Configure the UART module  //
</span>	<span class="c1">// ------------------------------- //
</span>	
	<span class="c1">// Find the Baud-Rate Divisor (BRD)
</span>	<span class="c1">// Formulas may be found in P903
</span>	<span class="c1">// BRD = 16,000,000 / (16*9600) = 104.1666666666667
</span>	<span class="c1">// UARTFBRD[DIVFRAC] = integer(0.166667 * 64 + 0.5) = 11
</span>	
	<span class="c1">// With the BRD values in hand, the UART configuration is written to the module in the following order:
</span>	
	<span class="c1">// 1. Disable the UART by clearing the UARTEN bit in the UARTCTL register.
</span>	<span class="n">UART0_CTL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// ~(0x00000001); // disable UART0
</span>	
	<span class="c1">// 2. Write the integer portion of the BRD to the UARTIBRD register.
</span>	<span class="n">UART0_IBRD_R</span> <span class="o">=</span> <span class="mi">104</span><span class="p">;</span>
	
	<span class="c1">// 3. Write the fractional portion of the BRD to the UARTFBRD register.
</span>	<span class="n">UART0_FBRD_R</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
	
	<span class="c1">// 4. Write the desired serial parameters to the UARTLCRH register 
</span>	<span class="n">UART0_LCRH_R</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x3</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 8 bit data, no parity bits, 1 stop bit, FIFOs
</span>	  
	<span class="c1">// 5. Configure the UART clock source by writing to the UARTCC register.
</span>	<span class="n">UART0_CC_R</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	
	<span class="c1">// 6. Optionally, configure the µDMA channel (see “Micro Direct Memory Access (µDMA)” on page 585)
</span>	<span class="c1">//    and enable the DMA option(s) in the UARTDMACTL register.
</span>
	<span class="c1">// 7. Enable the UART by setting the UARTEN bit in the UARTCTL register.
</span>	<span class="n">UART0_CTL_R</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">);</span>
	<span class="c1">//(bit 0: enable uart) (bit 8: enable Tx) (bit 9: enable Rx)
</span><span class="p">}</span>

<span class="c1">// Wait for new input, then return ASCII code
</span><span class="kt">char</span> <span class="n">uart0_in_char</span> <span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="c1">// wait until RXFE is 0 (buffer not empty)
</span>	<span class="k">while</span> <span class="p">((</span><span class="n">UART0_FR_R</span> <span class="o">&amp;</span> <span class="mh">0x0010</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>     
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">UART0_DR_R</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>	
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">uart0_out_char</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">){</span>
	<span class="c1">// wait until TXFF is 0 (buffer not full)
</span>	<span class="k">while</span> <span class="p">((</span><span class="n">UART0_FR_R</span> <span class="o">&amp;</span> <span class="mh">0x0020</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>      	
	<span class="n">UART0_DR_R</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">uart0_out_string</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uart0_out_char</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">++</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>
</p>

    <blockquote class="post_ending_note">
        <p><strong>ملاحظة</strong>: هذه المقالة تحت التحديث المستمر،، وملاحظاتكم وإقتراحاتكم ستساعد بإذن الله في إخراجها بالصورة التي كتبت من أجلها وهي تمهيد الطريق أمامكم لتعلم برمجة الأنظمة المدمجة </p>
    </blockquote>

    <hr>
      
          <a class="prev" href="/2018/07/18/spi.html">12. بروتوكول الإتصال المتزامن SPI</a> <br>
      
      
          <a class="next" href="/2018/06/20/pll.html">10. Phased Lock Loop - PLL</a> <br>
      
    <br>
    <hr>

<br>




<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = "http://localhost:4000/2018/07/06/uart.html";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/2018/07/06/uart"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://embedded-course.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            


      </section>
<!--      
      <footer>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
-->
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    <!--<script type="text/javascript" src="/assets/js/staticman.js"></script>-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-106571814-1', 'auto');
        ga('send', 'pageview');
    </script>
  
  </body>
</html>
