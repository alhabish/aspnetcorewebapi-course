<!doctype html>
<html dir="rtl" lang="ar-SA">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>بروتوكول الإتصال المتزامن I2C | لنتعلم برمجة الأنظمة المدمجة</title>
<meta property="og:title" content="بروتوكول الإتصال المتزامن I2C" />
<meta name="author" content="خالد الغامدي" />
<meta property="og:locale" content="ar_SA" />
<meta name="description" content="يعتبر الـ Inter-integrated Circuit - I2C نظام اتصال تسلسلي serial عالي السرعة وثنائي الاتجاه للربط مع الطرفيات كما هو الحال بالنسبة للـ SPI والـ UART. ويعتبر هذا البروتوكول أبطأ من SPI ولكنه يستخدم عدد أقل من الخطوط للإتصال حيث بالإمكان الإختيار بين أحد السرعات الأربع التالية:" />
<meta property="og:description" content="يعتبر الـ Inter-integrated Circuit - I2C نظام اتصال تسلسلي serial عالي السرعة وثنائي الاتجاه للربط مع الطرفيات كما هو الحال بالنسبة للـ SPI والـ UART. ويعتبر هذا البروتوكول أبطأ من SPI ولكنه يستخدم عدد أقل من الخطوط للإتصال حيث بالإمكان الإختيار بين أحد السرعات الأربع التالية:" />
<link rel="canonical" href="http://localhost:4000/2018/08/17/i2c.html" />
<meta property="og:url" content="http://localhost:4000/2018/08/17/i2c.html" />
<meta property="og:site_name" content="لنتعلم برمجة الأنظمة المدمجة" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-17T00:00:00+03:00" />
<script type="application/ld+json">
{"name":null,"description":"يعتبر الـ Inter-integrated Circuit - I2C نظام اتصال تسلسلي serial عالي السرعة وثنائي الاتجاه للربط مع الطرفيات كما هو الحال بالنسبة للـ SPI والـ UART. ويعتبر هذا البروتوكول أبطأ من SPI ولكنه يستخدم عدد أقل من الخطوط للإتصال حيث بالإمكان الإختيار بين أحد السرعات الأربع التالية:","author":{"@type":"Person","name":"خالد الغامدي"},"@type":"BlogPosting","url":"http://localhost:4000/2018/08/17/i2c.html","publisher":null,"image":null,"headline":"بروتوكول الإتصال المتزامن I2C","dateModified":"2018-08-17T00:00:00+03:00","datePublished":"2018-08-17T00:00:00+03:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/08/17/i2c.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script type="text/javascript" src="/assets/js/jquery-1.12.4.min.js" ></script>
    <script type="text/javascript" src="/assets/js/main.js"></script>
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>لنتعلم برمجة الأنظمة المدمجة</h1>
		<h3 text-align="left">Embedded Systems Programming Bootcamp</h3>
        <p>كورس تعليمي يهدف الى اكسابك المعرفة اللازمة والمهارات التقنية المتعلقة ببرمجة وتطوير الأنظمة المدمجة وفهم خصائصها ومكوناتها</p>
        <p class="view">
            <a href="/">الصفحة الرئيسية</a><br>
            <!--<a href="/#contents">الدروس</a><br>-->
            <a href="/lessons.html">قائمة الدروس</a><br>
            <a href="/feed.xml" title="Subscribe to our RSS feed">خدمة RSS</a>
        </p>
        <!--/assets/images/sidebar/rss.svg-->
          <!--<aside>-->
    <h3>للتواصل</h3>
    <ul class="social">
    <li><a href="https://github.com/alhabish/embedded-course" title="Github" class="github">Github</a></li>
    <li><a href="mailto:alhabish@gmail.com" title="Email" class="mail">Email</a></li>
    <li><a href="https://www.linkedin.com/in/khalidalghamidi" title="Linked in" class="linked">LinkedIn</a></li>
    <li><a href="http://www.twitter.com/alhabish" title="Twitter" class="twitter">Twitter</a></li>
    </ul>
    <!--</aside>-->
          
<!--        
        

        

        
-->
      </header>
      <section>

      <h1>13. بروتوكول الإتصال المتزامن I2C</h1>
<p class="meta">2018-08-17</p>


<!-- from https://github.com/cstack/db_tutorial -->


      
      

    <hr>
      
          <a class="prev" href="/2018/09/10/interrupts.html">14. المُقاطعات  Interrupts</a> <br>
      
      
          <a class="next" href="/2018/07/18/spi.html">12. بروتوكول الإتصال المتزامن SPI</a> <br>
      
    <br>
    <hr>

    <p><p>يعتبر الـ Inter-integrated Circuit - I2C نظام اتصال تسلسلي serial عالي السرعة وثنائي الاتجاه للربط مع الطرفيات كما هو الحال بالنسبة للـ SPI والـ UART. ويعتبر هذا البروتوكول أبطأ من SPI ولكنه يستخدم عدد أقل من الخطوط للإتصال حيث بالإمكان الإختيار بين أحد السرعات الأربع التالية:</p>

<ol>
  <li>قياسي - 100 كيلوبت في الثانية</li>
  <li>سريع - 400 كيلوبت في الثانية</li>
  <li>سرعة مضاعفة - 1 ميجابت في الثانية</li>
  <li>سرعة عالية - 3.33 ميجابت في الثانية</li>
</ol>

<p>الميزة الرئيسية التي تميز I2C عن UART و SPI هي أن ناقل I2C يمكنه دعم العديد من الأجهزة الرئيسية master والفرعية slave على نفس الناقل حيث تتيح لنا القدرة على دعم أجهزة متعددة في ناقل واحد تقليل عدد الأطراف pins الخارجية على المتحكم، مما يقلل من تكلفة وحجم الجهاز.</p>

<p>وبإمكان جميع الأجهزة المتصلة أن تعمل إما بالوضع الرئيسي master أو الفرعي slave. بالإضافة إلى أنه بإمكان هذه الأجهزة التبديل بين هذين الوضعين.</p>

<p>كما أن لكل جهاز متصل معرَف أو عنوان فريد unique address خاص به ومعيَن له مسبقاً، ولذلك يمكن للجهاز الرئيسي تحديد الجهاز الفرعي الذي سيقوم بالاتصال به.</p>

<hr />

<h2><a href=""></a> الهاردوير</h2>

<p>كل ما نحتاج اليه في هذا البروتوكول هما خطان:</p>

<p><strong>1. SCL - Serial Clock</strong></p>

<p>وهي تنقل إشارة الساعة والتي تنظم وتجدول نقل البيانات بين الأجهزة ويتم توليدها من الجهاز الرئيسي. وبما أن لدينا خط مستقل للساعة فذلك يجعل الـ I2C بروتوكول نقل متزامن synchronous.</p>

<p><strong>2. SDA - Serial Data</strong></p>

<p>هذا الخط مسؤول عن نقل البيانات.</p>

<p>في هذا البروتوكول يتم توصيل جميع الأجهزة الفرعية بشكل متوازي بالخطوط السابقة. فلو كان لديك أكثر من جهاز فرعي slave متصل بجهاز رئيسي واحد master فكل ما عليك فعله هو ربط جميع خطوط الـ SDA معاً وجميع خطوط الـ SCL معاً مما يجعلنا نحتاج الى إستخدام طرفين pins فقط لكل جهاز متصل، وهذه ميزة تحسب لصالح هذا البروتوكول.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/physical_layer.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/physical_layer.png');" />
    </td>
</tr>
</table>

<p>الخطان من نوع “تصريف مفتوح” open drain مما يعني أنه يجب إيصالهما بمقاومات لأعلى pull up resistors بحيث تكون الخطوط مرتفعة high، وهي الحالة الغير نشطة idle للناقل bus بينما عندما تكون الأجهزة على هذا الناقل نشطة تكون الخطوط منخفضة low. وللإيضاح أكثر، فإن الخطوط من هذا النوع تكون الأطراف المتصله بها غير متصلة بشكل مباشر بمصدر الطاقة VCC وإنما تتصل مباشرة بـ GND.</p>

<hr />

<h2><a href=""></a> البروتوكول</h2>

<p>بالإمكان الحصول على التفاصيل الكاملة لبروتوكول الـ I2C من الرابط التالي:</p>

<p>https://www.nxp.com/docs/en/user-guide/UM10204.pdf</p>

<p>ونذكر هنا سريعاً بعض الخصائص المتعلقة بهذا البروتوكول:</p>

<ul>
  <li>لكل جهاز فرعي عنوان فريد معين له مسبقاً ويتكون من 7 بت</li>
  <li>خطي الإشارة SCL و SDA هما ثنائي الاتجاه</li>
  <li>يتم إرسال البيانات بشكل متسلسل وتحتوي كل عملية إرسال على 8 بت</li>
  <li>هنالك مجموعة من السرعات التي يمكن الإختيار بينها وتتراوح بين 100 كيلوبت في الثانية وصولًا إلى 3.33 ميجابت في الثانية</li>
  <li>يتم نقل البيانات عن طريق إرسال الـ most significant bit msb أولاً</li>
  <li>البيانات المرسلة تكون محصورة بين إشارتي البدء والتوقف</li>
  <li>يعتبر الناقل bus غير نشط عندما يكونا كلا الخطين مرتفعين high</li>
</ul>

<hr />

<h2><a href=""></a> هيكل البيانات المرسلة والمستقبلة</h2>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/data_format.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/data_format.png');" />
    </td>
</tr>
</table>

<p>كنظرة عامة لتنسيق البيانات المرسله على الناقل فمن الممكن القول بأنها تأخذ الشكل التالي:</p>

<ol>
  <li>بت للبدء Start</li>
  <li>عنوان الجهاز الفرعي الذي سيتم إرسال البيانات إليه Address</li>
  <li>بت التأكيد ACK</li>
  <li>بعد ذلك لدينا سلسلة من البيانات على حسب إحتياجنا الى إرسالها أو أستقبالها</li>
  <li>بعد كل سلسلة مكونة من 8 بت يأتي بت التأكيد ACK</li>
  <li>بت للتوقف Stop</li>
</ol>

<p>وفيما يلي سنقوم بذكر تفاصيل الأجزاء المختلفة لهذا البروتوكول:</p>

<p><strong>بت البدء Start</strong></p>

<p>في البداية يكون كل من خطي SCL و SDA في الوضع المرتفع high بسبب مقاومات السحب لأعلى pull-up resistors، وهذا يعني أنه لا يوجد هنالك أي نشاط في الناقل bus. ومن أجل الإشارة إلى بدء عملية نقل البيانات، سيقوم الجهاز الرئيسي بخفض خط SDA بينما يكون خط SCL عالي. وتعتبر هذه إشارة البدء START حيث يمكن إعتبارها تنبيهاً لجميع الأجهزة المتصلة بالناقل حيث أنها تصبح مستعدة للاستماع للجهاز الرئيسي.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/start_condition.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/start_condition.png');" />
    </td>
</tr>
</table>

<p><strong>العنوان Address</strong></p>

<p>بعد بت البدء START، يقوم الجهاز الرئيسي بإرسال عنوان Address الجهاز الفرعي slave الذي يود التواصل معه وذلك عن طريق إرسال البت الأعلى most significant bit أولاً وإنتهاءاً بالبت الأدنى least significant bit. ويتكون العنوان من سبعة بتات لأن البت الثامنة هي بت التحكم بالإرسال والإستقبال R/S وتستخدم للإشارة الى ما اذا كان الجهاز الرئيسي سيقوم بالكتابة الى الجهاز الفرعي (0) أم القراءة منه (1) أي هل على الجهاز الفرعي الإستعداد لإستقبال بيانات أم هل هو طلب بيانات معينة من هذا الجهاز الفرعي .</p>

<p>بعد استلام العنوان، ستقوم جميع الأجهزة الفرعية بمقارنة العنوان المستلم من الجهاز الرئيسي بعنوانها الخاص فإذا تطابقت أستمرت في التواصل وإذا لم تتطابق فإنها تستمر في الانتظار حتى يصبح الناقل bus غير نشط وذلك بعد إرسال بت التوقف.</p>

<p><strong>التأكيد ACK</strong></p>

<p>سوف يستجيب الجهاز الفرعي الذي يتطابق معه العنوان بإرسال إشارة تأكيد ACK للإشارة الى أنه قد استلم بنجاح التسلسل السابق للبتات، وبذلك يقوم الجهاز الرئيسي بتحويل مسؤولية خط البيانات SDA الى الجهاز الفرعي.</p>

<p>وإذا ما كان الجهاز الفرعي قد تلقى التسلسل السابق بنجاح فإنه سيقوم بخفض خط SDL وهذا هو التأكيد ACK. أما اذا لم يقم الجهاز الفرعي بذلك فهذه الحالة الغير مؤكدة NACK وتعني بأن الجهاز الفرعي لم يستلم البتات السابقة بشكل صحيح لأي سبب كان.</p>

<p><strong>إرسال/إستقبال البيانات</strong></p>

<p>بعد تلقي إشارة ACK سيقوم الجهاز الرئيسي إما بنقل أو إستقبال البيانات حسب إشارة التحكم R/S المرسلة بعد عنوان الجهاز الفرعي. في حالة الإرسال، سيقوم الجهاز الرئيسي بإرسال البيانات بايت واحد في كل مرة ويستجيب الجهاز الفرعي بإرسال إشارة ACK بعد استلام كل بايت من البيانات. وعندما ينتهي الجهاز الرئيسي من إرسال جميع البيانات سيقوم بإرسال إشارة التوقف STOP.</p>

<p>أما في حالة أن الجهاز الرئيسي سيستقبل بيانات، فإن الجهاز الفرعي سيقوم بإرسال بايت البيانات الأول بعد إرسال إشارة ACK وسيستجيب الجهاز الرئيسي بإرسال إشارة ACK بعد استلام كل بايت من البيانات.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/sequence.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/sequence.png');" />
    </td>
</tr>
</table>

<p><strong>التوقف Stop</strong></p>

<p>بمجرد أن يتلقى الجهاز الرئيسي جميع البيانات فإنه سيرسل إشارة NACK متبوعة بإشارة STOP لإخلاء الناقل لأي عملية نقل بيانات أخرى. وتحدث إشارة التوقف عندما ينتقل خط SDA من الوضع المنخفض 0 الى الوضع المرتفع 1 بينما يكون خط الـ SCL مرتفع .</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/stop_condition.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/stop_condition.png');" />
    </td>
</tr>
</table>

<hr />

<h2><a href=""></a> تهيئة وضبط إعدادات الـ SPI</h2>

<p>توضح صفحة 1015 في دليل البيانات طريقة تهيئة الـ I2C وكيف يمكننا تهيئتها للعمل ضمن حالات معينة.</p>

<p>سنبدأ أولاً بشرح عملية التهيئة، ثم سنشرح كيفية إعداد الـ I2C لإرسال وإستقبال بايت واحد من البيانات كجهاز رئيسي.</p>

<p>أود الإشارة الى أننا في هذه الأمثلة لن نكتب عناوين السجلات بأنفسنا ولكننا سنستخدم تعريفات السجلات الموجودة في ملف التعريفات كما يلي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include "C:\ti\TivaWare_C_Series-2.1.4.178\inc\tm4c123gh6pm.h"
</span></code></pre>
</div>

<p>وفيما يلي الخطوات المتبعة لتهيئة الـ I2C:</p>

<p><strong>1. قم بتمكين ساعة الـ I2C باستخدام سجل RCGCI2C في وحدة التحكم في النظام (انظر صفحة 348).</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/RCGCI2C.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/RCGCI2C.png');" />
    </td>
</tr>
</table>

<p>سنستخدم في الأمثلة التالية I2C0 ولذلك سنقوم بكتابة 1 في الحقل R0 (بت 0)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">SYSCTL_RCGCI2C_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// activate I2C0
</span></code></pre>
</div>

<p><strong>2. قم بتمكين الساعة في وحدة GPIO المناسبة عبر سجل RCGCGPIO في وحدة التحكم في النظام (انظر صفحة 340). لمعرفة أي منفذ GPIO لتمكينه، راجع الجدول 5-23 في الصفحة 1351.</strong></p>

<p>بإمكاننا أن نرى في الجدول 5-23 بأن وحدة I2C0 موجودة في المنفذ B</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/table_23_5.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/table_23_5.png');" />
    </td>
</tr>
</table>

<p>ولذلك، لتفعيل المنفذ B نكتب 1 في حقل R1 (بت 1) في السجل RCGCGPIO:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/RCGCGPIO.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/RCGCGPIO.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">SYSCTL_RCGCGPIO_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// activate port B
</span></code></pre>
</div>

<p>وقبل أن نواصل، سنتأكد من ان المنفذ جاهز للعمل وذلك عن طريق قراءة القيمة الموجودة في الحقل R1 (بت 1) والتأكد من أنها تساوي 1.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/PRGPIO.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/PRGPIO.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">((</span><span class="n">SYSCTL_PRGPIO_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{};</span> <span class="c1">// is port B ready?
</span></code></pre>
</div>

<p><strong>3. في وحدة GPIO ، قم بتمكين الأطراف المناسبة للوظيفة البديلة باستخدام سجل GPIOAFSEL (انظر صفحة 671). لتحديد أي GPIOs لتهيئتها، راجع جدول 4-23 في الصفحة 1344.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/GPIOAFSEL.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/GPIOAFSEL.png');" />
    </td>
</tr>
</table>

<p>لقد ذكرنا سابقاً بأننا سنتعامل مع المنفذ B. وفي الجدول 5-23:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/table_23_5.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/table_23_5.png');" />
    </td>
</tr>
</table>

<p>يتضح لنا بأننا سنستخدم الطرف PB2 لـ SCL والطرف PB3 لـ SDA. ولذلك يتوجب علينا تفعيل الوظائف البديلة لهذه الأطراف:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTB_AFSEL_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// enable alt funct on PB2,3
</span></code></pre>
</div>

<p><strong>4. تمكين طرف I2CSDA لتفعيل خاصية الصرف (الإستنزاف) المفتوح open-drain. انظر الصفحة 676.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/GPIODR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/GPIODR.png');" />
    </td>
</tr>
</table>

<p>يمكّن هذا السجل خاصية الـ open-drain للأطراف المستخدمة في بروتوكول I2C. وفي بورد TI Tiva الذي نستخدمه، يتم تعيين المنفذ I2CSDA فقط كـ open-drain. وسوف يصبح المنفذ I2CSCL كذلك open-drain مع I2CSDA. أما تعيين I2CSCL كـ open-drain مباشرة لن يعمل.</p>

<p>وعلى ذلك سيتم تمكين خاصية open-drain لـ SDA فقط وذلك للطرف PB3.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTB_ODR_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// enable open drain on PB3 only
</span></code></pre>
</div>

<p>عند تفعيل خاصية الـ open-drain فإنه يتوجب علينا كتابة 1 في البت المقابل للطرف المستخدم وذلك في السجل GPIODEN:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/GPIODEN.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/GPIODEN.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTB_DEN_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// enable as digital signals
</span></code></pre>
</div>

<p><strong>5. قم بإعداد حقول PMCn في سجل GPIOPCTL لتعيين إشارات I2C إلى الأطراف المناسبة. انظر الى الصفحة 688 والجدول 5-23 في الصفحة 1351.</strong></p>

<p>بمجرد تمكيننا للوظائف البديلة، يتعين علينا عندئذ اختيار الوظيفة البديلة المحددة التي نريدها. في الجدول 5-23 في صفحة 1351 في دليل البيانات يمكننا رؤية أن I2C0 يقع في العمود 3:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/i2c0_pctl.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/i2c0_pctl.png');" />
    </td>
</tr>
</table>

<p>في هذا السجل - GPIOPCTL - كل 4 بت تمثل طرف، فالحقل PMC0 (بت0-3) يمثل الطرف 0، والحقل PMC1 (بت4-7) يمثل الطرف 1، وهكذا.</p>

<p>وكما ذكرنا سابقاً، بما أن I2C0 تقع في العمود رقم 3 فإننا نضع القيمة 3 في الحقول التي تمثل الأطراف التى نود تحويلها الى I2C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTB_PCTL_R</span> <span class="o">=</span> <span class="mh">0x00003300</span><span class="p">;</span> <span class="c1">// configure PB2,3 as I2C
</span></code></pre>
</div>

<p>كما أننا سنقوم بتعطيل الوظائف التماثلية analog للأطراف PB2 و PB3:</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/GPIOAMSEL.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/GPIOAMSEL.png');" />
    </td>
</tr>
</table>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">GPIO_PORTB_AMSEL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">));</span>  <span class="c1">// disable analog functionality on PB2,3
</span></code></pre>
</div>

<p><strong>6. قم بتهيئة الجهاز الرئيسي في I2C وذلك بكتابة القيمة 0x0000.0010 الى سجل I2CMCR.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/I2CMCR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/I2CMCR.png');" />
    </td>
</tr>
</table>

<p>نستخدم السجل I2CMCR لتحديد ما إذا كان الجهاز الذي نقوم ببرمجته هو الجهاز الرئيسي أم فرعي.</p>

<p>إسناد القيمة 1 الى الحقل MFE (بت 4) يجعل الجهاز الحالي هو الجهاز الرئيسي.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MCR_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// master function enable
</span></code></pre>
</div>

<p><strong>7. حدد سرعة ساعة SCL المطلوبة بـ 100 كيلوبت في الثانية عن طريق كتابة القيمة المطلوبة الى سجل I2CMTPR. تمثل القيمة المكتوبة الى سجل I2CMTPR عدد فترات ساعة النظام في فترة ساعة SCL واحدة. يتم تحديد قيمة TPR بالمعادلة التالية:</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>TPR = (System Clock / (2 * (SCL_LP + SCL_HP) * SCL_CLK)) - 1؛
</code></pre>
</div>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/I2CMTPR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/I2CMTPR.png');" />
    </td>
</tr>
</table>

<p>يمكن لوحدة الـ I2C العمل بأحد السرعات التالية:</p>

<ul>
  <li>قياسي Standard بسرعة 100 كيلوبت في الثانية</li>
  <li>سريع Fast بسرعة 400 كيلوبت في الثانية</li>
  <li>سرعة مضاعفة Fast-Mode Plus بسرعة 1 ميجابت في الثانية</li>
  <li>سرعة عالية High Speed بسرعة 3.33 ميجابت في الثانية</li>
</ul>

<p>يمكن تحديد السرعة المطلوبة بالكتابة الى الحقل TPR (بت 6:0) في السجل I2CMTPR</p>

<p>ويتم حساب قيمة TPR على النحو التالي:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">TPR</span> <span class="o">=</span> <span class="p">(</span><span class="n">System</span> <span class="n">Clock</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">SCL_LP</span> <span class="o">+</span> <span class="n">SCL_HP</span><span class="p">)</span> <span class="o">*</span> <span class="n">SCL_CLK</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre>
</div>

<p>حيث أن:</p>

<ul>
  <li>System Clock هي سرعة تردد ساعة النظام، وهي 16 ميجاهيرتز في حالتنا</li>
  <li>SCL_LP ثابته وتساوي 6</li>
  <li>SCL_HP ثابته وتساوي 4</li>
  <li>SCL_CLK هي السرعة المختارة لناقل الـ I2C، وهي 100 كيلوبت/ثانية في مثالنا</li>
</ul>

<p>وعلى ذلك نستطيع أن نستنتج قيمة TPR:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TPR = (16000000 / (2 * (6 + 4) * 100000)) - 1
TPR = (16000000 / (2 * 10 * 100000)) - 1
TPR = (16000000 / (2 * 10 * 100000)) - 1
TPR = (16000000 / 2000000) - 1
TPR = 8 - 1
TPR = 7
</code></pre>
</div>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MTPR_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// configure for 100 kbps clock
</span></code></pre>
</div>

<p>وفيما يلي جميع الخطوات المتبعة لتهيئة وحدة الـ I2C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">i20_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. Enable the I2C clock using the RCGCI2C register in the System Control module (see page 348).
</span>  <span class="n">SYSCTL_RCGCI2C_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// activate I2C0
</span>  
  <span class="c1">// 2. Enable the clock to the appropriate GPIO module via the RCGCGPIO register in the System 
</span>  <span class="c1">//    Control module (see page 340). To find out which GPIO port to enable, refer to Table 23-5 on page 1351.
</span>  <span class="n">SYSCTL_RCGCGPIO_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// activate port B
</span>  
  <span class="k">while</span> <span class="p">((</span><span class="n">SYSCTL_PRGPIO_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{};</span> <span class="c1">// is port B ready?
</span>
  <span class="c1">// 3. In the GPIO module, enable the appropriate pins for their alternate function using the 
</span>  <span class="c1">//    GPIOAFSEL register (see page 671). To determine which GPIOs to configure, 
</span>  <span class="c1">//    see Table 23-4 on page 1344.
</span>  <span class="n">GPIO_PORTB_AFSEL_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// enable alt funct on PB2,3
</span>  
  <span class="c1">// 4. Enable the I2CSDA pin for open-drain operation. See page 676.
</span>  <span class="n">GPIO_PORTB_ODR_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// enable open drain on PB3 only
</span>  
  <span class="n">GPIO_PORTB_DEN_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// enable digital I/O on PB2,3
</span>  
  <span class="c1">// 5. Configure the PMCn fields in the GPIOPCTL register to assign the I2C signals to the appropriate 
</span>  <span class="c1">//    pins. See page 688 and Table 23-5 on page 1351.                                        
</span>  <span class="n">GPIO_PORTB_PCTL_R</span> <span class="o">=</span> <span class="mh">0x00003300</span><span class="p">;</span> <span class="c1">// configure PB2,3 as I2C
</span>  
  <span class="n">GPIO_PORTB_AMSEL_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">));</span>  <span class="c1">// disable analog functionality on PB2,3
</span>  
  <span class="c1">// 6. Initialize the I2C Master by writing the I2CMCR register with a value of 0x0000.0010.
</span>  <span class="n">I2C0_MCR_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// master function enable
</span>  
  <span class="c1">// 7. Set the desired SCL clock speed of 100 Kbps by writing the I2CMTPR register with the correct 
</span>  <span class="c1">//    value. The value written to the I2CMTPR register represents the number of system clock periods 
</span>  <span class="c1">//    in one SCL clock period. The TPR value is determined by the following equation:
</span>  <span class="c1">//
</span>  <span class="c1">//    TPR = (System Clock/(2*(SCL_LP + SCL_HP)*SCL_CLK))-1;
</span>  <span class="c1">//    TPR = (16MHz/(2*(6+4)*100000))-1;
</span>  <span class="c1">//    TPR = 7
</span>  <span class="c1">//
</span>  <span class="c1">//    Write the I2CMTPR register with the value of 0x0000.0007.
</span>  <span class="n">I2C0_MTPR_R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// configure for 100 kbps clock
</span><span class="p">}</span>
</code></pre>
</div>

<hr />

<h2><a href=""></a> الإرسال</h2>

<p>يوضح المثال التالي كيفية إرسال الجهاز الرئيسي لبايت واحد في الـ I2C.</p>

<p>سنستخدم الصورة التوضيحية 8-16 في صفحة 1008 من دليل البيانات لإرشادنا. علماً أننا لن نطبق التسلسل الموجود في المربع.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/figure_16_8.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/figure_16_8.png');" />
    </td>
</tr>
</table>

<p><strong>8. حدد عنوان الجهاز الفرعي وبأن العملية التالية هي إرسال عن طريق الكتابة الى سجل I2CMSA.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/I2CMSA.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/I2CMSA.png');" />
    </td>
</tr>
</table>

<p>يجب علينا تحديد عنوان الجهاز الفرعي الذي نود الإرسال اليه عن طريق كتابة العنوان الى الحقل SA (بتات 7:1) في السجل I2CMSA.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MSA_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">slave</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// SA[7:1] is slave address
</span></code></pre>
</div>

<p>لاحظ أن العناوين في I2C مكونة من 7 بت فقط (بحد أقصى 127 جهازًا).</p>

<p>ويتم استخدام حقل R/S (بت 0) في نفس السجل للإشارة إلى ما إذا كنا سنرسل الى الجهاز الفرعي أم نستقبل منه.</p>

<p>وبما أننا سنرسل بيانات في هذا المثال فسنقوم بكتابة 0 الى الحقل R/S.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MSA_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// R/S[0] is 0 for send
</span></code></pre>
</div>

<p><strong>9. وضع البيانات (البايت الذي تود إرساله) في سجل البيانات I2CMDR.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/I2CMDR.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/I2CMDR.png');" />
    </td>
</tr>
</table>

<p>هذا السجل مسؤول عن كتابة البيانات الى خط SDA أو قراءة البيانات منه.</p>

<p>وفيما يلي سنقوم بكتابة بيانات بحجم 1 بايت الى حقل DATA (بت 7:0) في السجل I2CMDR.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MDR_R</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// place byte for transmission
</span></code></pre>
</div>

<p><strong>10. بدء إرسال بايت واحد من البيانات من الجهاز الرئيسي إلى الفرعي وذلك بكتابة القيمة 0x0000.0007 الى سجل I2CMCS.</strong></p>

<p>لسجل I2CMCS حالتان، أحدهما عندما نكتب الى هذا السجل والأخرى حينما نقرأ منه. ولذلك له وظيفتان مزدوجه.</p>

<p>فعندما نكتب اليه، فإنه يعمل كسجل متحكم control register وعندما نقرأ منه فإنه يعمل كسجل للحاله status register.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/I2CMCS_write.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/I2CMCS_write.png');" />
    </td>
</tr>
</table>

<p>سنقوم بكتابة القيمة 0x07 الى السجل I2CMCS وذلك لتبدأ وحدة الـ I2C بنقل بايت واحد من الجهاز الرئيسي الى الفرعي.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MCS_R</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span>
</code></pre>
</div>

<p>والسبب في أننا نكتب هذه القيمة بالذات هو لأننا سنضع 1 في حقل RUN (بت 0) و 1 في حقل START (بت 1) و 1 في حقل STOP (بت 2) مما يعطينا الرقم الثنائي 1110 أي 0x07.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MCS_R</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>     <span class="c1">// generate stop
</span>             <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>     <span class="c1">// generate start/restart
</span>             <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">// master enable
</span></code></pre>
</div>

<p>ولأننا جعلنا كل من START و RUN و STOP تساوي 1 فذلك سيجعل وحدة الـ I2C ترسل إشارة البدء Start ثم عنوان الجهاز الفرعي Slave Address ثم بت التحكم بالإرسال والإستقبال R/S ومن ثم ستتأكد من إستقبالها لبت التأكيد ACK ثم ستقوم بإرسال البيانات Data الموجوده في سجل البيانات وبعدها تتأكد مرة أخرى من بت التأكيد ACK وبعدها سترسل إشارة التوقف Stop لإنهاء عملية الإرسال.</p>

<p><strong>11. انتظر حتى اكتمال عملية الإرسال عن طريق التأكد من أن بت BUSBSY في السجل I2CMS يساوي 0.</strong></p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/I2CMCS_read.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/I2CMCS_read.png');" />
    </td>
</tr>
</table>

<p>لمتابعة عملية الإرسال والتأكد من أنها تمت يجب علينا مراقبة الحقل BUSBSY (بت 6) في السجل I2CMS الى أن يساوي 0 مما يعني أن عملية الإرسال قد أنتهت.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for transmission done
</span></code></pre>
</div>

<p><strong>12. تحقق من بت ERROR في سجل I2CMCS للتأكد من أنه تم الإرسال بشكل صحيح.</strong></p>

<p>عند اكتمال الإرسال ، يجب أن يتحقق البرنامج من بت الخطأ ERROR (بت 1)  في سجل I2CMCS للتأكد من عدم وجود خطأ في الإرسال.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">return</span> <span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//check for error
</span></code></pre>
</div>

<p>وفيما يلي الدالة الكاملة لإرسال الجهاز الرئيسي لبايت واحد:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">i2c0_send_1_byte</span><span class="p">(</span><span class="kt">int8_t</span> <span class="n">slave</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">){</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for I2C ready
</span>  
  <span class="c1">// 8. Specify the slave address of the master and that the next operation is a Transmit by writing the 
</span>  <span class="c1">//    I2CMSA register with a value of 0x0000.0076. This sets the slave address to 0x3B.  
</span>  <span class="n">I2C0_MSA_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">slave</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// SA[7:1] is slave address
</span>  <span class="n">I2C0_MSA_R</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// R/S[0] is 0 for send
</span>  
  <span class="c1">// 9. Place data (byte) to be transmitted in the data register by writing the I2CMDR register with the 
</span>  <span class="c1">//    desired data.
</span>  <span class="n">I2C0_MDR_R</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// place byte for transmission
</span>  
  <span class="c1">// 10. Initiate a single byte transmit of the data from Master to Slave by writing the I2CMCS register 
</span>  <span class="c1">//     with a value of 0x0000.0007 (STOP, START, RUN).
</span>  <span class="n">I2C0_MCS_R</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>     <span class="c1">// generate stop
</span>               <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>     <span class="c1">// generate start/restart
</span>               <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">// master enable
</span>					   	
  <span class="c1">// 11. Wait until the transmission completes by polling the I2CMCS register's BUSBSY bit until it has 
</span>  <span class="c1">//     been cleared.
</span>  <span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for transmission done
</span>  
  <span class="k">return</span> <span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//check for error
</span><span class="p">}</span>
</code></pre>
</div>

<hr />

<h2><a href=""></a> الإستقبال</h2>

<p>يوضح المثال التالي كيفية تلقي الجهاز الرئيسي لبايت واحد في الـ I2C.</p>

<p>سنستخدم  الصورة التوضيحية 9-16 في صفحة 1009 من دليل البيانات لإرشادنا. علماً أننا لن نطبق التسلسل الموجود في المربع.</p>

<table style="border: 1px solid #CACFD2">


<tr>
    <td style="text-align:center; align:center">
        <img src="http://localhost:4000/assets/files/article_13/figure_16_9.png" alt="" style="cursor: pointer;" onclick="openInNewTab('http://localhost:4000/assets/files/article_13/figure_16_9.png');" />
    </td>
</tr>
</table>

<p>الطريقة مشابهه الى حد كبير لما قمنا به عند إرسال بايت واحد. ولكننا سنمر عليها سريعاً هنا:</p>

<p><strong>1. تكرار محاولة القراءة طالما وجد خطأ في إستقبال البيانات ولم نجتاز العدد المحدد من المحاولات.</strong></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code>  <span class="k">do</span><span class="p">{</span>
          <span class="c1">// code
</span>  <span class="p">}</span>                                         
  <span class="k">while</span><span class="p">(((</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retry_counter</span> <span class="o">&lt;=</span> <span class="n">max_retries</span><span class="p">));</span>
</code></pre>
</div>

<p><strong>2. الإنتظار الى أن تصبح وحدة الـ I2C جاهزة.</strong></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for I2C ready
</span></code></pre>
</div>

<p><strong>3. كتابة عنوان الجهاز الفرعي.</strong></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MSA_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">slave</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// SA[7:1] is slave address
</span></code></pre>
</div>

<p><strong>4. الإشارة الى أننا نطلب إستقبال بيانات.</strong></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MSA_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// R/S[0] is 1 for receive
</span></code></pre>
</div>

<p><strong>5. إرسال المعلومات السابقة.</strong></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">I2C0_MCS_R</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>     <span class="c1">// generate stop
</span>             <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>     <span class="c1">// generate start/restart
</span>             <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">// master enable
</span></code></pre>
</div>

<p><strong>6. التأكد من إكتمال عملية الإرسال.</strong></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for transmission done
</span></code></pre>
</div>

<p><strong>7. قراءة البايت المستقبل.</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>return (I2C0_MDR_R &amp; 0xFF);
</code></pre>
</div>

<p>وفيما يلي الدالة الكاملة لإستقبال الجهاز الرئيسي لبايت واحد:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="n">i2c0_recv_1_byte</span><span class="p">(</span><span class="kt">int8_t</span> <span class="n">slave</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_retries</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">retry_counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">do</span><span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for I2C ready
</span>    
	<span class="n">I2C0_MSA_R</span> <span class="o">=</span> <span class="p">(</span><span class="n">slave</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// SA[7:1] is slave address
</span>    <span class="n">I2C0_MSA_R</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// R/S[0] is 1 for receive
</span>    
	<span class="n">I2C0_MCS_R</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span>     <span class="c1">// generate stop
</span>                 <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span>     <span class="c1">// generate start/restart
</span>                 <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">// master enable
</span>    
	<span class="k">while</span> <span class="p">(</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="p">{};</span> <span class="c1">// wait for transmission done
</span>    
	<span class="o">++</span><span class="n">retry_counter</span><span class="p">;</span>  <span class="c1">// increment retry counter
</span>  <span class="p">}</span>  <span class="c1">// repeat if error
</span>  <span class="k">while</span><span class="p">(((</span><span class="n">I2C0_MCS_R</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retry_counter</span> <span class="o">&lt;=</span> <span class="n">max_retries</span><span class="p">));</span>
  
  <span class="k">return</span> <span class="p">(</span><span class="n">I2C0_MDR_R</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
</p>

    <blockquote class="post_ending_note">
        <p><strong>ملاحظة</strong>: هذه المقالة تحت التحديث المستمر،، وملاحظاتكم وإقتراحاتكم ستساعد بإذن الله في إخراجها بالصورة التي كتبت من أجلها وهي تمهيد الطريق أمامكم لتعلم برمجة الأنظمة المدمجة </p>
    </blockquote>

    <hr>
      
          <a class="prev" href="/2018/09/10/interrupts.html">14. المُقاطعات  Interrupts</a> <br>
      
      
          <a class="next" href="/2018/07/18/spi.html">12. بروتوكول الإتصال المتزامن SPI</a> <br>
      
    <br>
    <hr>

<br>




<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = "http://localhost:4000/2018/08/17/i2c.html";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/2018/08/17/i2c"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://embedded-course.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            


      </section>
<!--      
      <footer>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
-->
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    <!--<script type="text/javascript" src="/assets/js/staticman.js"></script>-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-106571814-1', 'auto');
        ga('send', 'pageview');
    </script>
  
  </body>
</html>
